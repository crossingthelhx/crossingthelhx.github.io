<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Leonlist&#39;s Temporary Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Leonlist&#39;s Temporary Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Leonlist">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Leonlist's Temporary Blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leonlist's Temporary Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">临时博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/26/%E5%BE%AE%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leonlist's Temporary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/26/%E5%BE%AE%E6%9C%BA/" itemprop="url">微机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-26T11:17:15+08:00">
                2021-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="微机原理与汇编语言"><a href="#微机原理与汇编语言" class="headerlink" title="微机原理与汇编语言"></a>微机原理与汇编语言</h1><p>教材《微型计算机原理与接口技术》</p>
<p>内容主要以8086为主要对象，包括微型计算机的基础知识、8086CPU、寻址方式、指令系统、汇编语言程序设计和存储器。</p>
<h2 id="微型计算机的基础知识和发展状况"><a href="#微型计算机的基础知识和发展状况" class="headerlink" title="微型计算机的基础知识和发展状况"></a>微型计算机的基础知识和发展状况</h2><ul>
<li>进制转换、原码、反码、补码</li>
<li>冯·诺依曼计算机结构</li>
<li>微型计算机基本结构</li>
</ul>
<h2 id="微处理器的结构和工作模式"><a href="#微处理器的结构和工作模式" class="headerlink" title="微处理器的结构和工作模式"></a>微处理器的结构和工作模式</h2><h3 id="8086-CPU基本结构"><a href="#8086-CPU基本结构" class="headerlink" title="8086 CPU基本结构"></a>8086 CPU基本结构</h3><h3 id="8086-CPU内部寄存器"><a href="#8086-CPU内部寄存器" class="headerlink" title="8086 CPU内部寄存器"></a>8086 CPU内部寄存器</h3><ul>
<li><p>数据寄存器</p>
<ul>
<li>AX 累加器</li>
<li>BX 基地址指针，存放偏移地址</li>
<li>CX 计数寄存器</li>
<li>DX 数据寄存器</li>
</ul>
</li>
<li><p>地址指针和变址寄存器</p>
<ul>
<li>SP 堆栈指针</li>
<li>BP 基址指针</li>
<li>SI 源变址寄存器</li>
<li>DI 目的变址寄存器</li>
<li>BX 基址寄存器</li>
</ul>
</li>
<li><p>段寄存器</p>
<ul>
<li>CS 代码段寄存器</li>
<li>DS 数据段寄存器</li>
<li>SS 堆栈段寄存器</li>
<li>ES 附加段寄存器</li>
</ul>
</li>
<li><p>指令指针 IP</p>
</li>
<li><p>标志寄存器 FLAGS</p>
<ul>
<li>CF 进位标志</li>
<li>PF 奇偶校验标志</li>
<li>AF 辅助进位标志</li>
<li>ZF 零标志</li>
<li>SF 符号标志</li>
<li>OF 溢出标志</li>
<li>TF 陷阱标志</li>
<li>IF 中断标志</li>
<li>DF 方向标志</li>
</ul>
</li>
<li><p>8086 CPU的引脚功能</p>
<ul>
<li>AD15~AD0，地址/数据总线，双向、三态、分时复用信号</li>
<li>A19/S6~A16/S3，地址/状态线</li>
<li>RD 读控制信号</li>
<li>WR 写控制信号</li>
<li></li>
</ul>
</li>
<li><p>8086 CPU的存储器组织</p>
</li>
<li><p>最小模式系统</p>
</li>
<li><p>总线操作时序</p>
</li>
</ul>
<h2 id="8086-的寻址方式和指令系统"><a href="#8086-的寻址方式和指令系统" class="headerlink" title="8086 的寻址方式和指令系统"></a>8086 的寻址方式和指令系统</h2><h3 id="8086-的寻址方式"><a href="#8086-的寻址方式" class="headerlink" title="8086 的寻址方式"></a>8086 的寻址方式</h3><ul>
<li><p><strong>立即寻址方式</strong></p>
<p>立即数作为源操作数</p>
</li>
<li><p><strong>寄存器寻址方式</strong></p>
<p>操作数包含在寄存器中，由指令指定寄存器的名称</p>
<p>注意：源操作数的长度必须与目的操作数一致，比如不能把AH的内容传送到CX中</p>
</li>
<li><p>存储器寻址方式</p>
<ul>
<li><p><strong>直接寻址方式</strong></p>
<p>物理地址=16*DS+EA，默认为DS为基地址，EA上必须加方括号，与立即数区分</p>
<p>（段超越前缀）ES:[500H]，以ES作基地址</p>
<p>可以用符号地址代替数值地址，实际上就是给存储单元起一个名字</p>
</li>
<li><p><strong>寄存器间接寻址方式</strong></p>
<p>源操作数的寄存器的值为操作数的有效地址，寄存器名称外必须加方括号</p>
<p>如果指令中指定的寄存器为BX、SI、DI，段地址为数据段DS</p>
<p>如果为BP，段地址为堆栈段SS</p>
<p>MOV BX，[SI]</p>
<p>允许段超越前缀</p>
</li>
<li><p><strong>寄存器相对寻址方式</strong></p>
<p>与寄存器间接寻址类似，就是在有效地址上加一个位移量</p>
<p>MOV BX, COUNT[SI]，位移量COUNT</p>
<p>也允许段超越前缀</p>
<p>MOV DH, ES:ARRAY[SI]</p>
</li>
<li><p><strong>基址变址寻址方式</strong></p>
<p>操作数的有效地址为一个基址寄存器（BX或BP）和一个变址寄存器（SI和DI）的内容之和</p>
<p>MOV AX, [BX+SI]    物理地址=16*DS+BX+SI</p>
<p>基址寄存器为BX时，段址寄存器为DS；基址寄存器为BP时，段寄存器为SS</p>
</li>
<li><p><strong>相对基址变址寻址方式</strong></p>
<p>操作数的有效地址为一个基址寄存器（BX或BP）和一个变址寄存器（SI和DI）的内容，再加上指令中指定的8位或16为位移量之和。</p>
<p>就是在基址变址寻址方式上加上位移量</p>
</li>
</ul>
</li>
<li><p>其他寻址方式</p>
<ul>
<li>隐含寻址</li>
<li>I/O 端口寻址</li>
<li>一条指令作几种寻址方式</li>
<li>转移类指令寻址</li>
</ul>
</li>
</ul>
<h3 id="机器语言指令编码格式"><a href="#机器语言指令编码格式" class="headerlink" title="机器语言指令编码格式"></a>机器语言指令编码格式</h3><h3 id="8086-指令系统"><a href="#8086-指令系统" class="headerlink" title="8086 指令系统"></a>8086 指令系统</h3><ul>
<li><p><strong>MOV 传送指令</strong></p>
<p>IP 寄存器不能用作源操作数或目的操作数</p>
<p>立即数和CS 寄存器不能用作目的操作数</p>
<p>MOV 指令不能在两个存储单元之间直接传送数据，也不能在两个段寄存器之间直接传送数据</p>
</li>
<li><p><strong>PUSH 进栈指令</strong></p>
<p>源操作数可以是16位通用寄存器、段寄存器或存储器中的数据字，但不能是立即数</p>
</li>
<li><p><strong>POP 出栈指令</strong></p>
<p>源操作数可以是16位通用寄存器、段寄存器或存储单元，但CS不能用作目的操作数</p>
</li>
<li><p><strong>XCHG 交换指令</strong></p>
<p>XCHG 目的， 源     把源操作数和目的操作数相交换</p>
<p>交换可以在寄存器之间、寄存器和存储器之间，但段寄存器不能作为操作数，也不能直接交换两个存储单元之间的内容</p>
</li>
<li><p><strong>XLAT 表转换指令</strong></p>
</li>
<li><p><strong>IN 输入指令</strong></p>
</li>
<li><p><strong>LEA 取有效地址指令</strong></p>
<p>LEA 目的， 源</p>
<p>取源操作数地址的偏移量，并把它传送目的操作数所在单位</p>
<p>源操作数必须是存储单元，而且目的操作数必须是一个除段寄存器之外的16位寄存器</p>
</li>
<li><p><strong>LDS将双字指针送到寄存器和DS指令</strong></p>
<p>LDS 目的， 源</p>
<p>从源操作数指定的存储单元中，取出一个变量的4字节地址指针，送进一对目的寄存器</p>
<p>指令中源操作数必须是存储单元，从该存储单元开始的连续4个字节单元 中，存放着一个变量的地址指针。目的操作数必须是16位寄存器，通常使用SI寄存器，但是不能使用段寄存器</p>
</li>
<li><p><strong>LES将双字指针送到寄存器和ES指令</strong></p>
<p>LES 目的， 源</p>
<p>与LDS指令操作基本相同，不同是将源操作数所指向的地址指针中的段地址部分送到ES寄存器中，而不是DS寄存器，目的操作数常用DI寄存器</p>
</li>
<li><p><strong>LAHF 标志送到 AH 指令</strong></p>
<p>把标志寄存器SF、ZF、AF、PF和CF分别传送到AH寄存器位7，6，4，2和0</p>
</li>
<li><p><strong>SAHF AH送标志寄存器</strong></p>
<p>把AH内容存入标志寄存器</p>
</li>
<li><p><strong>PUSHF 标志入栈指令</strong></p>
</li>
<li><p><strong>POPF 标志出栈指令</strong></p>
</li>
<li><p><strong>ADD 加法指令</strong></p>
</li>
<li><p><strong>ADC 带进位的加法指令</strong></p>
<p>在两个操作数相加的同时，还要把进位标志CF 的当前值加进去作为和，再把结果送到目的操作数中</p>
</li>
<li><p><strong>INC 增量指令</strong></p>
<p>INC 目的</p>
<p>对目的操作数加一</p>
</li>
<li><p><strong>AAA 加法的ASCII调整指令</strong></p>
</li>
<li><p><strong>DAA 加法的ASCII调整指令</strong></p>
</li>
<li><p><strong>SUB 减法指令</strong></p>
</li>
<li><p><strong>SBB 带借位的减法指令</strong></p>
</li>
<li><p><strong>NEG 取负指令</strong></p>
</li>
<li><p><strong>CMP 比较指令</strong></p>
<p>将目的操作数减去源操作数，但仅将结果反映在标志位上</p>
</li>
<li><p><strong>AAS 减法的ASCII调整指令</strong></p>
</li>
<li><p><strong>DAS 减法的十进制调整指令</strong></p>
</li>
<li><p><strong>MUL 无符号数乘法指令</strong></p>
</li>
<li><p><strong>IMUL 整数乘法指令</strong></p>
</li>
<li><p><strong>DIV 无符号数除法指令</strong></p>
</li>
<li><p><strong>IDIV 整数除法指令</strong></p>
</li>
<li><p><strong>CBW 把字节转换为字指令</strong></p>
<p>将寄存器AL中字节的符号位扩充到AH的所有位</p>
</li>
<li><p><strong>CWD 把字转换成双字指令</strong></p>
<p>把AX中的字的符号位扩充到DX寄存器的所有位中去</p>
</li>
<li><p><strong>AAD 除法的ASCII调整指令</strong></p>
</li>
<li><p><strong>NOT取反指令</strong></p>
<p>将目的操作数求反</p>
<p>目的操作数可以是8位或16位寄存器或存储器，指令执行后，对标志位无影响</p>
</li>
<li><p><strong>AND 逻辑与指令</strong></p>
<p>对两个操作数进行按位逻辑与操作，结果返回目的操作数</p>
</li>
<li><p><strong>OR 逻辑或指令</strong></p>
<p>对两个操作数进行按位逻辑或操作，结果返回目的操作数</p>
</li>
<li><p><strong>XOR 异或操作指令</strong></p>
<p>对两个操作数进行按位逻辑异或运算，结果返回目的操作数</p>
</li>
<li><p><strong>TEST 测试指令</strong></p>
<p>对两个操作数进行按位逻辑与操作，并修改标志位，但不回送结果</p>
</li>
<li><p><strong>SAL 算术左移指令</strong></p>
</li>
<li><p><strong>SHL 逻辑左移指令</strong></p>
<p>上面两条指令的功能完全相同，每移动一次，最低有效位LSB补0，最高有效位MSB进入标志位CF</p>
</li>
<li><p><strong>SHR 逻辑右移指令</strong></p>
<p>最高位补0</p>
</li>
<li><p><strong>SAR 算数右移指令</strong></p>
<p>最高位（符号位）保持不变</p>
</li>
<li><p><strong>ROL 循环左移指令</strong></p>
</li>
<li><p><strong>ROR 循环右移指令</strong></p>
</li>
<li><p><strong>RCL 通过进位位循环左移指令</strong></p>
</li>
<li><p><strong>RCR 通过进位位循环右移指令</strong></p>
</li>
<li><p><strong>MOVS 字符串传送指令</strong></p>
<p>REP MOVSB 等价于</p>
<p>MOVS NEW_LOC, SRC_MESS</p>
<p>​            DEC CX</p>
<p>​             JNZ AGAIN</p>
</li>
<li><p><strong>CMPS 字符串比较指令</strong></p>
</li>
<li><p><strong>SCAS 字符串扫描指令</strong></p>
</li>
<li><p><strong>LODS 数据串装入指令</strong></p>
</li>
<li><p><strong>STOS 数据串存储指令</strong></p>
<p>将累加器AL或AX中的一个字节或字，传送到附加段中以DI为目标指针的目的串中，同时修改DI，以2指向串中的下一个单元</p>
</li>
<li><p><strong>JMP 无条件转移指令</strong></p>
<p>使程序无条件的转移到指令中的目的地址去执行</p>
</li>
<li></li>
</ul>
<h1 id="复习题"><a href="#复习题" class="headerlink" title="复习题"></a>复习题</h1><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol>
<li><p><strong>寻址方式？</strong></p>
<p>寄存器间接寻址、直接寻址、寄存器相对寻址、基址加变址寻址、基址加变址相对寻址。</p>
</li>
<li><p><strong>数据操作数的种类？</strong></p>
<p>立即数、寄存器数和内存单元数</p>
</li>
<li><p><strong>段地址、偏移地址与物理地址之间的关系？有效地址EA又是指什么？</strong></p>
<p>段地址左移四位加上偏移地址形成20位的物理地址。EA是指段内偏移地址，即表示段内某单元相对于段起始地址的空间位置。</p>
</li>
<li><p><strong>能用于寄存器间接寻址及变址寻址的寄存器有哪些？它们通常与哪个段寄存器配合形成物理地址？</strong></p>
<p>基址寄存器BX和BP，变址寄存器SI和DI</p>
<p>BX、SI、DI与DS配合形成物理地址，而BP与SS配合形成物理地址。</p>
</li>
<li><p><strong>什么是堆栈操作？</strong></p>
<p>堆栈被定义为一种先进后出的数据结构，即最后进栈的元素将被最先弹出来。堆栈从一个称为栈底的位置开始，数据进入堆栈的操作称为压入（或压栈），数据退出堆栈的操作称为弹出，每进行一次弹出操作，堆栈就减少一个元素，最后一次压入的元素，称为栈顶元素，压入弹出操作都是对栈顶元素进行的堆栈的两种基本的操作。</p>
</li>
<li><p><strong>用汇编语言指令实现以下操作</strong></p>
<p><strong>(1)将寄存器AX、BX和DX的内容相加，和放在寄存器DX中。</strong></p>
<p><code>ADD AX，BX</code></p>
<p><code>ADD DX，AX</code></p>
<p><strong>(2)用基址变址寻址方式（BX和SI）实现AL寄存器的内容和存储器单元BUF中的一个字节相加的操作，和放到AL中。</strong></p>
<p><code>ADD AL，BYTE PTR [BX][SI]</code></p>
<p><strong>(3)用寄存器BX实现寄存器相对寻址方式（位移量为100H），将DX的内容和存储单元中的一个字相加，和放到存储单元中。</strong></p>
<p><code>ADD 100H[BX]，DX</code></p>
<p><strong>(4)用直接寻址方式（地址为0500H）实现将存储器中的一个字与立即数3ABCH相加，和放回该存储单元中。</strong></p>
<p><code>ADD [0500H]，3ABCH</code></p>
<p><strong>(5)用串操作指令实现将内存定义好的两个字节串BUF1和BUF2相加后的和，存放到另一个串BUF3中的功能。</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">CX</span>, COUNT</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">SI</span>, OFFSET BUF1</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DI</span>, OFFSET BUF3</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>, OFFSET BUF2</span><br><span class="line"><span class="symbol">AGAIN:</span> <span class="keyword">LODSB</span> <span class="comment">;取[DS]:SI中的字节</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">AL</span>, [<span class="built_in">BX</span>] <span class="comment">;与[DS]:BX中的字节相加</span></span><br><span class="line"><span class="keyword">STOSB</span>     <span class="comment">;存入[ES]:DI中</span></span><br><span class="line"><span class="keyword">INC</span> <span class="built_in">BX</span></span><br><span class="line"><span class="keyword">DEC</span> <span class="built_in">CX</span></span><br><span class="line"><span class="keyword">JNZ</span> AGAIN</span><br><span class="line">……</span><br></pre></td></tr></table></figure></li>
<li><p><strong>指出下列指令中，源操作数及目的操作数的寻址方式。</strong></p>
<p>SUB BX，[BP+35]  ；寄存器寻址、寄存器相对寻址</p>
<p>MOV AX，2030H  ；寄存器寻址、立即寻址</p>
<p>SCASB        ；隐含操作数为寄存器寻址和寄存器间接寻址</p>
<p>IN AL，40H     ；寄存器寻址、立即寻址</p>
<p>MOV [DI+BX]，AX  ；基址加变址寻址、寄存器寻址</p>
<p>ADD AX，50H[DI]  ；寄存器寻址、寄存器相对寻址</p>
<p>MOV AL，[1300H]  ；寄存器寻址、直接寻址</p>
<p>MUL BL       ；寄存器寻址、目的操作数为隐含寄存器寻址</p>
</li>
<li><p><strong>已知（DS）= 1000H，（SI）= 0200H，（BX）= 0100H，（10100H）= 11H，（10101H）= 22H，（10600H）= 33H，（10601H）= 44H，（10300H）= 55H，（10301H）= 66H，（10302H）= 77H，（10303H）= 88H，试分析下列各条指令执行完后AX寄存器的内容。</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，<span class="number">2500H</span>     （<span class="built_in">AX</span>）=<span class="number">2500H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，<span class="number">500H</span>[<span class="built_in">BX</span>]   （<span class="built_in">AX</span>）==<span class="number">4433H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="number">300H</span>]     （<span class="built_in">AX</span>）=<span class="number">6655H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="built_in">BX</span>]      （<span class="built_in">AX</span>）=<span class="number">2211H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="built_in">BX</span>][<span class="built_in">SI</span>]    （<span class="built_in">AX</span>）=<span class="number">6655H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="built_in">BX</span>+<span class="built_in">SI</span>+<span class="number">2</span>]   （<span class="built_in">AX</span>）=<span class="number">8877H</span></span><br></pre></td></tr></table></figure></li>
<li><p>判断下列指令是否有错，如果有错，说明理由。 </p>
<table>
<thead>
<tr>
<th>SUB BL，BX</th>
<th>两个操作数的宽度不一样</th>
</tr>
</thead>
<tbody><tr>
<td>MOV [DI]，[SI]</td>
<td>两个操作数不能同时为内存数</td>
</tr>
<tr>
<td>MOV AX，BYTE PTR[SI]</td>
<td>源操作数限定为字节，与目的操作数宽度不一致</td>
</tr>
<tr>
<td>MOV 125，CL</td>
<td>立即数不能做目的操作数</td>
</tr>
<tr>
<td>MOV CS，BX</td>
<td>不能对CS实现传送操作</td>
</tr>
<tr>
<td>SHR AX，4</td>
<td>只有当移位位数为1时，才能用立即数表达</td>
</tr>
<tr>
<td>MOV AH，[SI][DI]</td>
<td>不能用两个变址寄存器来实现寻址操作</td>
</tr>
<tr>
<td>SHL AX，CH</td>
<td>移位指令的移位位数用CL给出，不能用CH。</td>
</tr>
<tr>
<td>MOV  BYTE PTR[BX]，3456H</td>
<td>将16位的立即数传送到一个字节的内存单元</td>
</tr>
</tbody></table>
</li>
<li><p><strong>设（DS）= 1000H，（ES）= 2000H，（SS）= 3000H，（SI）= 0080H，（BX）= 02D0H，（BP）= 0060H，试指出下列指令的源操作数字段是什么寻址方式？它的物理地址是多少？</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，<span class="number">0CBH</span> 立即寻址</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="number">100H</span>] 直接寻址，物理地址为：<span class="number">10100H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="built_in">BX</span>] 寄存器间接寻址，物理地址为：<span class="number">102D0H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="built_in">BP</span>] 寄存器间接寻址，物理地址为：<span class="number">20060H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="built_in">BP</span>+<span class="number">50</span>] 寄存器相对寻址，物理地址为：<span class="number">200B0H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>，[<span class="built_in">BX</span>][<span class="built_in">SI</span>] 基址加变址寻址，物理地址为：<span class="number">10350H</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>分别说明下列每组指令中的两条指令的区别.</strong></p>
<p><strong>（1） AND CL，0FH 按位相“与”，高4位为“0000”，低4位保留原值；</strong></p>
<p>OR CL，0FH 按位相“或”，高4位为原值，低4位为“1111”。</p>
<p><strong>（2） MOV AX，BX  将BX寄存器的内容传送到AX寄存器中；</strong></p>
<p>MOV AX，[BX] 将BX寄存器所指的内存单元的内容送AX寄存器中。</p>
<p><strong>（3） SUB BX，CX  BX寄存器内容减去CX寄存器的内容，结果送回到BX；</strong></p>
<p>CMP BX，CX  BX内容减去CX内容，结果只影响标志位。</p>
<p><strong>（4） AND AL，01H AL内容与01H相“与”，结果为“0000000x”送回AL寄存器；</strong></p>
<p>TEST AL，01H AL内容与01H相“与”，结果只影响标志位（ZF）。</p>
<p><strong>（5） JMP NEAR PTR NEXT NEXT所指指令在当前指令的同段内；</strong></p>
<p>JMP SHORT NEXT NEXT所指指令在当前指令的8位地址范围内。</p>
<p><strong>（6） ROL AX，CL 循环左移，进位标志位不参与循环；</strong></p>
<p>RCL AX，CL 循环左移，进位标志位参与循环。</p>
<p><strong>（7） PUSH AX 将AX内容存入栈顶指针处，即进栈操作；</strong></p>
<p>POP AX 将栈顶内容弹出装入AX寄存器中，即出栈操作。</p>
</li>
<li><p><strong>试分析以下程序段执行完后BX的内容为何？</strong></p>
<p>MOV BX，1030H</p>
<p>MOV CL，3</p>
<p>SHL BX，CL  逻辑左移</p>
<p>DEC BX  减一</p>
<p>程序执行完后，<strong>BX=817FH</strong></p>
</li>
<li><p><strong>编写能实现以下功能的程序段。</strong></p>
<p><strong>根据CL中的内容决定程序的走向，设所有的转移都是短程转移。若D0位等于1，其他位为0，转向LAB1；若D1位等于1，其他位为0，转向LAB2；若D2位等于1，其他位为0，转向LAB3；若D0、D1、D2位都是1，则顺序执行。</strong></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="keyword">AND</span> <span class="built_in">CL</span>，<span class="number">07H</span></span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">CL</span>，<span class="number">01H</span></span><br><span class="line"><span class="keyword">JZ</span> LAB1</span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">CL</span>，<span class="number">02H</span></span><br><span class="line"><span class="keyword">JZ</span> LAB2</span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">CL</span>，<span class="number">04H</span></span><br><span class="line"><span class="keyword">JZ</span> LAB3</span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">CL</span>，<span class="number">07H</span></span><br><span class="line"><span class="keyword">JNZ</span> OVER</span><br><span class="line">……</span><br><span class="line">LAB1： ……</span><br><span class="line">LAB2： ……</span><br><span class="line">LAB3： ……</span><br><span class="line">OVER：……</span><br></pre></td></tr></table></figure></li>
<li><p><strong>程序段1:</strong></p>
<p>MOV AX,4455H</p>
<p>MOV BX,7722H</p>
<p>PUSH AX</p>
<p>POP CX</p>
<p>XCHG BX, CX</p>
<p>程序执行后 <strong>AX = 4455H, BX = 4455H， CX = 7722H</strong>.</p>
</li>
<li><p><strong>程序段2：</strong></p>
<p>MOV AX, 8765H</p>
<p>MOV DX,4321H</p>
<p>MOV CL，04</p>
<p>SHL DX，CL</p>
<p>MOV BL，AH</p>
<p>SHL AX，CL</p>
<p>SHR BL，CL</p>
<p>OR DL，BL</p>
<p>程序执行后 <strong>AX= 7650H,  DX= 3218H</strong> </p>
</li>
<li><p><strong>程序段3：</strong></p>
<p>TABLE    DW 11H，2233H，4455H，6677H，88H</p>
<p>​       …</p>
<p>​       MOV BX, OFFSET TABLE</p>
<p>​       MOV AX, [BX]</p>
<p>​       MOV DX, [BX+3]</p>
<p>程序执行后，<strong>AX = 0011H, DX= 5522H</strong></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leonlist's Temporary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url">编译原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-24T14:38:57+08:00">
                2021-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h1><p><strong>终结符和非终结符</strong></p>
<p>终结符可以简单地理解为「推导到这里就终结了」，也就是说不能再继续通过生成式向下推倒的元素就是终结符。</p>
<p>比如 T-&gt;abc。T 推导为串 abc 后已经得到了实质上的字符，不用在向下推导了，那么 T 为非终结符，abc 无法继续推导，则为终结符。（在一系列生成式中，式子左边的一定是非终结符，从未出现在式子左边的一定是终结符）</p>
<p><strong>句子与句型</strong></p>
<p>如果符号串x是由起始符号推导出的，则称x是文法G[S]的句型。</p>
<p>如果x中只包含终结符，则称x是文法G[S]的句子。</p>
<p>文法描述的语言是该文法一切句子的集合。</p>
<p><strong>四种文法</strong></p>
<p>0型文法：α→β，其中α至少包含一个非终结符。</p>
<p>1型文法（上下文有关文法）：α→β，其中|β|≥|α|，S→ε除外。</p>
<p>2型文法（上下文无关文法）：a→β，其中a是一个非终结符。</p>
<p>3型文法（规范文法）：A→a或A→aB.</p>
<p>4种文法是逐渐增加限制的，所以规范文法一定是0型文法、1型文法、2型文法，上下文无关文法也一定是0型文法、1型文法…</p>
<p><strong>上下文有关文法与上下文无关文法</strong></p>
<p>在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。上下文无关指，只要文法的定义里有某个产生式，不管一个非终结符前后的串是什么，就可以应用相应的产生式进行推导。</p>
<p>上下文无关文法例子：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">产生式：</span><br><span class="line">Sent -&gt; S V O</span><br><span class="line">S -&gt; 人 | <span class="type">天</span></span><br><span class="line"><span class="type">V</span> -&gt; 吃 | <span class="type">下</span></span><br><span class="line"><span class="type">O</span> -&gt; 雨 | <span class="type">雪 | 饭 | 肉</span></span><br></pre></td></tr></table></figure>

<p>这个文法可以生成如下句子（共 16 种组合）：</p>
<p>｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝</p>
<p>可以看到，其中有一些搭配在语义上是不恰当的，例如”天吃肉“。其（最左）推导过程为：</p>
<p>Sent -&gt; SVO -&gt; 天VO -&gt; 天吃O -&gt; 天吃肉</p>
<p>而上下文有关文法例子如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">Sent -&gt; S V O</span><br><span class="line">S -&gt; 人 | <span class="type">天</span></span><br><span class="line"><span class="type">人V</span> -&gt; 人吃</span><br><span class="line">天V -&gt; 天下</span><br><span class="line">下O -&gt; 下雨 | <span class="type">下雪</span></span><br><span class="line"><span class="type">吃O</span> -&gt; 吃饭 | <span class="type">吃肉</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里对 V 的推导过程施加了约束：虽然 V 还是能推出”吃“和”下“两个词，但是仅仅当 V 左边是”人“时，才允许它推导出”吃“；而当 V 左边是”天“时，允许它推导出”下“。这样通过上下文的约束，就保证了主谓搭配的一致性。类似地，包含 O 的产生式也约束了动宾搭配的一致性。（就是语法的强约束条件，导致上下文有关了）</p>
<p>这样一来，这个语言包含的句子就只有｛人吃饭，天下雨，人吃肉，天下雪｝这四条，都是语义上合理的。</p>
<p>以”人吃饭“为例，推导过程为：</p>
<p>Sent -&gt; SVO -&gt; 人VO -&gt; 人吃O -&gt; 人吃饭</p>
<p>（这与语法的歧义性还是不同的，要有所区分）</p>
<p><strong>1型文法比2型文法识别的语言集合更大？</strong></p>
<p>上例看到，感觉上下文有关文法所解释的句子集合更少。</p>
<p>这里的“1型文法比2型文法<strong>识别的语言集合</strong>更大” 这里的集合不是产生的结果集（字符串集合），而是语言规则集。 2型文法规则一定是1型文法规则，而有些语言能用1型文法规则描述，但用2型文法规则描述不出来。</p>
<h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><h3 id="最左推导-最右推导-规范句型"><a href="#最左推导-最右推导-规范句型" class="headerlink" title="最左推导/最右推导/规范句型"></a>最左推导/最右推导/规范句型</h3><p>例如 E+E   (i+i)：</p>
<ul>
<li>E+E =&gt; E+i =&gt; i+i  ——最右推导</li>
<li>E+E =&gt; i+E =&gt; i+i   ——最左推导</li>
</ul>
<p><strong>最左推导</strong>是指：任何一步α=&gt; β都是对α中的最左非终结符进行替换。</p>
<p>同样，可定义<strong>最右推导</strong>（又称规范推导）：任何一步α=&gt;β都是对α中的最右非终结符进行替换。</p>
<p>由规范推导所得到的句型称为<strong>规范句型</strong>。</p>
<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>一个文法的某个句子对应两棵不同的语法树，则这个文法是二义的。</p>
<p>或一个文法的某个句子有两个不同的最左（右）推导，则这个文法是二义的。</p>
<p>人们已证明，二义性问题是不可判定的，即不存在一个算法，它能在有限步骤内，确切地判断一个文法是否是二义的。（做题时就画两颗不同的语法树来证明其二义性）</p>
<h3 id="自上而下的分析法"><a href="#自上而下的分析法" class="headerlink" title="自上而下的分析法"></a>自上而下的分析法</h3><p>基本思想：从文法的开始符号出发，反复使用各种产生式，寻找“匹配”输入符号串的推导。即对任何输入符号串，从文法的开始符号（根结）出发，自上而下地为输入串建立一棵语法树，直到语法树结果正好是输入的符号串为止。</p>
<h3 id="自下而上的分析法"><a href="#自下而上的分析法" class="headerlink" title="自下而上的分析法"></a>自下而上的分析法</h3><p>基本思想：从输入串开始，逐步进行“归约”，直至归约到文法的开始符号。即从语法树的末端开始，步步向上“归约”，直到根结。</p>
<h3 id="短语、直接短语、句柄"><a href="#短语、直接短语、句柄" class="headerlink" title="短语、直接短语、句柄"></a>短语、直接短语、句柄</h3><ol>
<li><p><strong>短语</strong></p>
<p>令文法G，开始符号为S，αβδ是G的句型（即S=&gt;αβδ），如果S=&gt;αAδ且A=&gt;β，则称β是句型αβδ相对于非终结符A的短语。</p>
</li>
<li><p><strong>直接短语</strong></p>
<p>如短语中有A=&gt;β，则称β是句型相对于规则A→β的直接短语。</p>
</li>
<li><p><strong>句柄</strong></p>
<p>一个句型的最左直接短语称为该句型的句柄。</p>
</li>
</ol>
<p>⒈ 先证明前提</p>
<p>⒉ 给出语法树（注意文法是否是二义性的）</p>
<p>　如题文法G[E]:   E→ E+E|E*E|(E) | i</p>
<p>  证明i+i*i是G的一个句型，并指出这个句型的所有短语、直接短语、句柄。</p>
<p>⒊ 根据每棵语法树得出短语、直接短语、句柄</p>
<p>　（注意编号）</p>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="NFA→-DFA的转换（NFA的确定化）"><a href="#NFA→-DFA的转换（NFA的确定化）" class="headerlink" title="NFA→ DFA的转换（NFA的确定化）"></a>NFA→ DFA的转换（NFA的确定化）</h2><h3 id="确定化的有关运算"><a href="#确定化的有关运算" class="headerlink" title="确定化的有关运算"></a>确定化的有关运算</h3><p><strong>（1）ε_closure(I) ——状态集合I的ε闭包(等价状态集)</strong></p>
<p> 设I是状态集的一个子集，ε_closure(I)定义为：</p>
<p>​    a.若S∈I，则S∈ε_closure(I)；</p>
<p>​    b. 若S∈I，那么从S出发经过任意ε弧而能到达的任意状态S’都属于ε_closure(I)；</p>
<p><strong>（2）Move(I, a)——状态集合I的a弧转换</strong></p>
<p> 假定I是状态集的一个子集，a是Σ中的一个字符，定义</p>
<p>​            Ia <strong>＝</strong> ε_closure(J)</p>
<p>其中J是所有那些可从I中的某一状态出发经过一条a弧而到达的状态结的全体。</p>
<p>　<strong>(3)Ia＝ ε_closure(Move(I, a))</strong></p>
<h3 id="子集化的具体过程"><a href="#子集化的具体过程" class="headerlink" title="子集化的具体过程"></a>子集化的具体过程</h3><p>为了方便起见，令Σ中只有a,b两个字母，即Σ＝{a, b}</p>
<p>（1）构造一张表，此表的每一行有三列，第一列为I，第二列为Ia，第二列为Ib。即</p>
<table>
<thead>
<tr>
<th align="center">I</th>
<th align="center">Ia</th>
<th align="center">Ib</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ε_closure(K0)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>首先置该表的第一列为ε_closure(K0)</p>
<p>（2）一般而言，若某一行的第一列的状态子集已确定，例如记为I，则可以求出Ia和Ib</p>
<p>（3）检查Ia和Ib是否已在表的第一列中出现，把未曾出现者填入到后面空行的第一列位置上。</p>
<p>（4）对未重复Ia 、Ib的新行重复上述过程(2)、(3)，直到所有第二列和第三列的子集全部在第一列中出现</p>
<p><strong>DFA 的初态位该表第一行第一列的状态</strong></p>
<p><strong>DFA 的终态为含有原 NFA 的终态的状态子集</strong></p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20210516181303298.png" alt="image-20210516181303298" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>I</th>
<th>Ia</th>
<th>Ib</th>
<th>S</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>{0,1,2,4,7}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7}</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7,9}</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>{1,2,4,5,6,7}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7}</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>{1,2,4,5,6,7,9}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7,10}</td>
<td>3</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>{1,2,4,5,6,7,<strong>10</strong>}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7}</td>
<td><strong>4</strong></td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<h2 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h2><ol>
<li>将得到的状态进行划分 ∏ ，划分为两部分，一部分为终态，一部分为为非终组。</li>
<li>继续进行划分，通过其可以匹配的字符进行判断，若该组内所有成员匹配字符都落在同一组内，即不可再分，否则重新划分组</li>
<li>若 ∏new = ∏ ，则进入步骤4，否则返回2</li>
<li>在分组 ∏new 每个组中选取一个状态作为代表，代表DFA的最简状态。</li>
</ol>
<h2 id="正规式→NFA"><a href="#正规式→NFA" class="headerlink" title="正规式→NFA"></a>正规式→NFA</h2><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20210516193619828.png" alt="image-20210516193619828" style="zoom:67%;" />

<h1 id="自顶向下语法分析方法"><a href="#自顶向下语法分析方法" class="headerlink" title="自顶向下语法分析方法"></a>自顶向下语法分析方法</h1><p>对于任一输入符号串，从文法的识别符号出发，根据当前的输入符号，<strong>唯一的确定一个产生式</strong>，用产生式的右部的符号串替代相应的非终结符往下推导，或构造一棵语法树。若能推导出输入串或构造语法树成功则输入串是句子，否则不是。</p>
<h2 id="开始符号FIRST集合"><a href="#开始符号FIRST集合" class="headerlink" title="开始符号FIRST集合"></a>开始符号FIRST集合</h2><p><strong>理解</strong></p>
<p>FIRST(A)是以A开始符的集合，A的所有可能推导的开头终结符或者是ε</p>
<p><strong>例子</strong></p>
<ol>
<li><p>后面跟的不是非终结符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A-&gt;aB|ε</span><br><span class="line">A-&gt;c</span><br><span class="line">...</span><br><span class="line">First(A)&#x3D;&#123;a,ε,c&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后面跟非终结符（一）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A-&gt;Ba</span><br><span class="line">A-&gt;b</span><br><span class="line">...</span><br><span class="line">First(A)&#x3D;&#123;b&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后面跟的非终结符（二）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A-&gt;Bc</span><br><span class="line">B-&gt;b|ε</span><br><span class="line">...</span><br><span class="line">First(A)&#x3D;&#123;b,c&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后面跟的非终结符（三）</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A-&gt;BC</span><br><span class="line">B-&gt;b|<span class="type">ε</span></span><br><span class="line"><span class="type">C</span>-&gt;c|<span class="type">ε</span></span><br><span class="line"><span class="type">...</span></span><br><span class="line"><span class="type">First</span>(A)=&#123;b,c,ε&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>构造文法G的每一文法符号X，X ∈ (VT∪VN)</p>
<ul>
<li><p>如果 X 是终结符号，那么FIRST(X)={X}</p>
</li>
<li><p>如果 X 是非终结符号，且 X -&gt; Y1Y2Y3…Yk 是产生式</p>
<ul>
<li>如果a在FIRST(Yi)中，且 ε 在FIRST(Y1)，FIRST(Y2)，…，FIRST(Yi-1)中，那么a也在FIRST(X)中；</li>
<li>如果ε 在FIRST(Y1)，FIRST(Y2)，…，FIRST(Yk)中，那么ε在FIRST(X)中；</li>
</ul>
</li>
<li><p>如果X是非终结符号，且有X-&gt;ε，那么ε在FIRST(X)中</p>
</li>
</ul>
<h2 id="后跟符号FOLLOW集合"><a href="#后跟符号FOLLOW集合" class="headerlink" title="后跟符号FOLLOW集合"></a>后跟符号FOLLOW集合</h2><p><strong>理解</strong></p>
<p>Follow(A)为非终结符A后跟符号的集合，Follow(A)是所有句型中出现在紧接A之后的终结符或’#‘</p>
<p><strong>求解规则</strong></p>
<p>将标记 # 放到 FOLLOW(S) 中</p>
<p>按照下面两个规则<strong>不断迭代</strong>，直到所有的 FOLLOW 集合都不再增长为止</p>
<ul>
<li>如果存在产生式 A -&gt; αBβ ，那么 FIRST(β) 中所有非 ε 的符号都在 FOLLOW(B) 中；</li>
<li>如果存在产生式 A -&gt; αB，或者 A -&gt; αBβ 且 FIRST(β) 包含 ε，那么 FOLLOW(A) 中的所有符号都加入到 FOLLOW(B) 中</li>
</ul>
<p><strong>理解求解规则</strong></p>
<ol>
<li><p>将标记 # 放到 FOLLOW(S) 中</p>
</li>
<li><p>形如A -&gt; αBβ</p>
<p>（α可以是终结符或者非终结符或者直接为空，β可以是终结符或者非终结符，注意β不能为空，B后面要有东西）</p>
<p>比如</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B</span><br><span class="line">A-&gt;cB</span><br><span class="line"></span><br><span class="line">A-&gt;dBC</span><br><span class="line">C-&gt;ε</span><br></pre></td></tr></table></figure>

<p>那么 FOLLOW(A) 中的所有符号都加入到 FOLLOW(B) 中</p>
<p><strong>例子一</strong></p>
<p>注意：[if] 是一个终结符，同理[b] [other] [else] [then]</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G(S)：S-&gt;IETSP|<span class="type">O</span></span><br><span class="line">I-&gt;<span class="keyword">if</span></span><br><span class="line">E-&gt;b</span><br><span class="line">O-&gt;other</span><br><span class="line">L-&gt;<span class="keyword">else</span></span><br><span class="line">T-&gt;<span class="keyword">then</span></span><br><span class="line">P-&gt;LS|<span class="type">ε</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>First</strong></th>
<th><strong>Follow</strong></th>
</tr>
</thead>
<tbody><tr>
<td>First(S)={if,other}</td>
<td>Follow(S)={井号 ,else}</td>
</tr>
<tr>
<td>First(I)={if}</td>
<td>Follow(I)={b}</td>
</tr>
<tr>
<td>First(E)={b}</td>
<td>Follow(E)={then}</td>
</tr>
<tr>
<td>First(O)={other}</td>
<td>Follow(O)={else,井号}</td>
</tr>
<tr>
<td>First(L)={else}</td>
<td>Follow(L)={if,other}</td>
</tr>
<tr>
<td>First(P)={else,ε}</td>
<td>Follow(P)={else,井号}</td>
</tr>
<tr>
<td>First(T)={then}</td>
<td>Follow(T)={if,other}</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Select集合"><a href="#Select集合" class="headerlink" title="Select集合"></a>Select集合</h2><p><strong>理解</strong></p>
<ol>
<li>如果a不能=&gt;ε，则 Select(A-&gt;a)=First(a)</li>
<li>如果a=&gt;ε，则 Select(A-&gt;a)=(First(a)-{ε})UFollow(A)</li>
</ol>
<h2 id="LL-1-文法的判别"><a href="#LL-1-文法的判别" class="headerlink" title="LL(1) 文法的判别"></a>LL(1) 文法的判别</h2><h3 id="满足定义"><a href="#满足定义" class="headerlink" title="满足定义"></a>满足定义</h3><ol>
<li>求出能推出ε的非终结符</li>
<li>求FIRST集合；</li>
<li>求FOLLOW集合；</li>
<li>计算SELECT集合。</li>
<li>对同一非终结符的不同产生式求Select交集</li>
</ol>
<h2 id="某些非LL-1-文法到LL-1-文法的等价转换"><a href="#某些非LL-1-文法到LL-1-文法的等价转换" class="headerlink" title="某些非LL(1)文法到LL(1)文法的等价转换"></a>某些非LL(1)文法到LL(1)文法的等价转换</h2><h3 id="存在左公因子"><a href="#存在左公因子" class="headerlink" title="存在左公因子"></a>存在左公因子</h3><p>解决方法：提取左公因子</p>
<p>若文法中存在形如：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;ay|<span class="type">ab</span>   </span><br><span class="line">两个产生式左部第一个符号相同，则不符合LL（<span class="number">1</span>）文法，指代不明，则表示存在左公因子</span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line">转换成 A-&gt;aM1,aM2，aM3....的形式：</span><br><span class="line">得：</span><br><span class="line">A-&gt;aM</span><br><span class="line">M-&gt;y|<span class="type">b</span></span><br><span class="line">则成功提取左公因子；</span><br></pre></td></tr></table></figure>

<h3 id="存在左递归"><a href="#存在左递归" class="headerlink" title="存在左递归"></a>存在左递归</h3><p><strong>（1）直接左递归</strong> </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>-&gt;AB, <span class="selector-tag">A</span>∈Vn，<span class="selector-tag">B</span>属于V*</span><br></pre></td></tr></table></figure>

<p>方法：左递归变右递归</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;β1P&#x27;|<span class="string">β2P&#x27;</span>|<span class="string">…</span>|<span class="string">βnP&#x27;</span></span><br><span class="line"><span class="string">P&#x27;-&gt;α1P&#x27;</span>|<span class="string">α2P&#x27;</span>|<span class="string">…</span>|<span class="string">αmP&#x27;</span>|<span class="string">ε</span></span><br></pre></td></tr></table></figure>

<p>例：给定文法G(S):</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E-&gt;E+T|<span class="type">T</span></span><br><span class="line">T-&gt;T*F|<span class="type">F</span></span><br><span class="line">F-&gt;(E)|<span class="type">i</span></span><br></pre></td></tr></table></figure>

<p>消除其直接左递归G(E):</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E-&gt;T<span class="string">E&#x27;</span></span><br><span class="line"><span class="string">E&#x27;</span>-&gt;+T<span class="string">E&#x27;|ε</span></span><br><span class="line"><span class="string">T-&gt;FT&#x27;</span></span><br><span class="line">T<span class="string">&#x27;-&gt;*FT&#x27;</span>|ε</span><br><span class="line">F-&gt;(E)|i</span><br></pre></td></tr></table></figure>



<p><strong>（2）间接左递归</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>-&gt;Bb</span><br><span class="line"><span class="selector-tag">B</span>-&gt;Aa</span><br><span class="line"><span class="selector-tag">A</span>,<span class="selector-tag">B</span>∈Vn，<span class="selector-tag">a</span>，<span class="selector-tag">b</span>属于V*</span><br></pre></td></tr></table></figure>

<p>（这里第二种情况注意，因为是左递归，所以看得就是第一个字符，一定要跟这个类型一样的A-&gt;B…. 以及B-&gt;A…. 这种才是左递归，如果A-&gt;B…. ,B-&gt;aA…,  这种就不是左递归了，因为样式不同，请注意）</p>
<p>同样消除左递归的方法：</p>
<p>如果是间接左递归，则先转换成直接左递归：</p>
<p>例子：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;Bb | <span class="type">c</span></span><br><span class="line">B-&gt;Aa</span><br></pre></td></tr></table></figure>

<p>将B-&gt;Aa代入到另一个式子：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;Aab | <span class="type">c</span></span><br></pre></td></tr></table></figure>

<p>转换</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;cM</span><br><span class="line">M-&gt;abM</span><br><span class="line">M-&gt;ε</span><br></pre></td></tr></table></figure>




          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leonlist's Temporary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/09/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" itemprop="url">软件项目管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-09T19:17:28+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Reading-1"><a href="#Reading-1" class="headerlink" title="Reading 1"></a>Reading 1</h1><p><a href="https://link.zhihu.com/?target=http://www.joelonsoftware.com/articles/fog0000000069.html">Things You Should Never Do, Part I</a></p>
<p>这是国外的老程序员 Joel Spolsky 在2000年写的文章。</p>
<p>更详尽的带图表的分析:</p>
<p><a href="https://link.zhihu.com/?target=http://vibratingmelon.com/2011/06/10/why-you-should-almost-never-rewrite-code-a-graphical-guide/">Why You Should (Almost) Never Rewrite Code – A Graphical Guide</a></p>
<hr>
<p>Avram Joel Spolsky生于1965年，他是一位软件工程师和作家。他是“Joel on Software”博客的作者。他从1991年到1994年间担任Microsoft Excel团队的项目经理。在2000年，他创立了Fog Creek软件并开启了“<a target="_blank" rel="noopener" href="http://www.joelonsoftware.com/index.html">Joel on Software</a>”博客。2008年，他和Jeff Atwood一起启动了如今极为成功的Stack Overflow程序员问答网站。他们用Stack Exchange软件产品作为<a target="_blank" rel="noopener" href="http://stackoverflow.com/">Stack Overflow</a>的引擎。现如今<a target="_blank" rel="noopener" href="http://stackexchange.com/">Stack Exchange</a>网络已经包含了91个站点。</p>
<hr>
<p>他在这篇文章的论点来源于一个简单的事实：<br><strong>It’s harder to read code than to write it.</strong><br><strong>写代码容易，读代码难。</strong></p>
<p>在开头，他批评网景公司<strong>犯了的最严重的战略错误</strong>——<strong>他们决定从头开始重写代码</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于网景当时的极度成功，公司规模扩展很快，为了应对开发的需求而收购了一家大型软件开发公司。但这家被收购公司的高层以及开发人员做了一系列愚蠢决定，包括使用当时如麻花一般的 <span class="built_in">C</span><span class="operator">++</span> 代替 <span class="built_in">C</span>，削减支持平台，优先发布 <span class="variable">Windows</span> 版本浏览器等，最后造成了新版本发布遥遥无期，程序质量不高等一系列问题，失去了对其他浏览器（包括<span class="variable">IE</span>）功能上和性能上的绝对优势，而结果就是被用户抛弃。</span><br></pre></td></tr></table></figure>

<p>作者的观点主要有：</p>
<ol>
<li>重写的代码即便能完全达到旧代码的所有功能、性能需求，为产品带来的竞争力也只有边际提升。（这个很好理解，因为代码的规范性和清晰度对产品的功能性没有直接帮助，只能降低远期的维护成本）</li>
<li>由于重写代码过程中需要花费额外的钱和时间，可能会出现一些意外状况，比如预算不够了，核心程序员离职了，或是重写的产品没有达到原有产品的所有功能和性能需求，那么这个结果可能是灾难性的，重写的产品要么胎死腹中，要么市场竞争力反而更低了。</li>
<li>在重写期间，由于竞争对手不会停滞不前并且您无法开发新功能，因此产品的竞争力通常会下降。而且重写花费的时间比预期的要长得多，连锁效应使产品竞争力下降的时间更长。对于小公司来说，这可能是致命的。</li>
</ol>
<p>上面三个中的任何一个都可能致命，但是所有三个问题肯定都是致命的，产品的竞争力可能永远不会恢复。</p>
<p>如果公司的项目或产品代码混乱到无法再加入新功能或提升性能，跟时代严重脱节怎么办，那么应用以上原则，这时候既然这个项目已经快死了，那么放到新项目里重写显然是最合理的选择。</p>
<h1 id="Reading-2"><a href="#Reading-2" class="headerlink" title="Reading 2"></a>Reading 2</h1><p>同样是 Joel Spolsky 在2000年写的文章。</p>
<p><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a></p>
<hr>
<p>他用这十二条来评估软件团队的质量，大多数软件组织的运行得分为2或3，像 Microsoft 这样的公司的得分为12。</p>
<ol>
<li>Do you use source control?</li>
<li>Can you make a build in one step?</li>
<li>Do you make daily builds?</li>
<li>Do you have a bug database?</li>
<li>Do you fix bugs before writing new code?</li>
<li>Do you have an up-to-date schedule?</li>
<li>Do you have a spec?</li>
<li>Do programmers have quiet working conditions?</li>
<li>Do you use the best tools money can buy?</li>
<li>Do you have testers?</li>
<li>Do new candidates write code during their interview?</li>
<li>Do you do hallway usability testing?</li>
</ol>
<hr>
<p><strong>1.您是否使用源代码管理？</strong></p>
<p>如果您没有源代码控制，那么您将不得不尝试使程序员们一起工作。程序员无法知道其他人做了什么。错误不能轻易回滚。</p>
<p>在源代码层面使其易于管理、维护，同时降低核心技术泄密风险。</p>
<p><strong>2.你们可以把整个系统从源码到CD映像文件一步建成吗？</strong></p>
<p>这句话问的问题是：从你们最新的源码开始到建立起能够交出去的最后文件，你们有多少步骤要做？ 一个好的团队应该有一个批处理程序一步便可将所有的工作做完，像把源文件提取出来，跟据不同的语言版本要求（英文版，中文版），和各种编译开关（#ifdef）进行编译，联接成可执行文件，标上版本号，打包成CD映像文件或直接送到网站上去，等等等等。</p>
<p><strong>3.您是否进行日常构建？</strong></p>
<p>在微软软件开发中，每日构建是最重要的过程之一，被称为微软产品开发的“心跳”。简单来看，每天构建系统将整个产品解决方案完整构建一遍，生成的目标文件和安装文件被放置在一个共享位置。接着，安装文件被自动部署到release server上，随后可以自动运行BVT（build verification test），并将所有结果寄送每个team member的信箱。</p>
<p><strong>4.您是否有 bug 数据库？</strong></p>
<p>如果您正在开发代码，即使是一个团队，也没有列出代码中所有已知错误的有组织的数据库，那么您将交付低质量的代码。</p>
<p><strong>5.在编写新代码之前，您是否修复了 bug？</strong></p>
<p>要立即修复 bug 的原因之一：因为它花费的时间更少。还有另一个原因，这与以下事实有关：预测编写新代码要比修复现有 bug 要花多长时间。例如，如果我要求您预测编写代码以对列表进行排序所需的时间，那么您可以给我一个很好的估计。但是，如果我问你如何预测这将需要多长时间来修复 bug：如果安装Internet Explorer 5.5您的代码不工作，你甚至无法猜测的，因为你不知道（定义）是什么导致 bug。跟踪可能需要3天，或者可能需要2分钟。</p>
<p>这意味着如果您的日程安排中有许多尚待修复的 bug，则该日程安排是不可靠的。但是，如果您已经解决了所有已知的 bug，而剩下的只是新代码，那么您的日程安排将更加准确。</p>
<p>将 bug 计数保持为零的另一个很棒的事情是，您可以更快地响应竞争。一些程序员认为这是使产品随时准备就的准备*。然后，如果您的竞争对手推出了一种吸引用户的杀手级新功能，则您可以实施该功能并当场发货，而无需修复大量累积的 bug。</p>
<p><strong>6.您有最新的时间表吗？</strong></p>
<p>这使我们按计划进行。如果您的代码对企业至关重要，则有很多原因说明知道何时完成代码对企业很重要。</p>
<p>制定时间表的另一个关键之处在于，它迫使您决定要执行的功能，然后迫使您选择最不重要的功能并将其剪切掉，而不是陷入特征<a target="_blank" rel="noopener" href="http://www.netmeg.net/jargon/terms/c/creeping_featuritis.html">成熟度</a>（又称范围蠕动）。</p>
<p><strong>7.您有写软件规格说明书（SPEC）吗？</strong></p>
<p>在产品的前期设计过程中，如果你发现了一些问题，你可以轻易地在说明书里该几行字就行了。一旦进入了写程序的阶段，解决问题的代价就要高得多了。</p>
<p>没有产品开发详细说明书就开始写程序，往往会导致程序写的乱七八糟，而且左拖右拖不能交付使用。</p>
<p>不论采用以上哪种方法，道理只有一个：在没有产品开发详细说明书之前，决不可写程序。</p>
<p><strong>8.程序员有安静的工作条件吗？</strong></p>
<p>通过为知识工作者提供空间，安静和私密性，可以广泛地记录生产率的提高。</p>
<p><strong>9.您是否使用金钱可以买到的最好的工具？</strong></p>
<p>要给予程序员尽可能好的条件</p>
<p><strong>10.您有测试员吗？</strong></p>
<p>需要有测试员来检测产品的漏洞</p>
<p><strong>11.新候选人在面试中是否写代码？</strong></p>
<p>通过写代码了解程序员的能力，而不是看似漂亮的简历和问几个简单的问题（如CreateDialog()和DialogBox()有什么区别？这种问题，查一下帮助文件就知道了）</p>
<p><strong>12.您是否进行走廊可用性测试？</strong></p>
<p>也就是随便抓一个人来，进行测试。</p>
<p>走廊实用性测试对于企业产品测试来讲提供的反馈比招募来做测试得出的结论要好很多，而且很多时候是完全相反的结论。</p>
<p>但现在很多企业都不做走廊测试了，而改用poll这种电子方式在Social Media发布，让用户选择。原因是走廊测试这种方法的效率不高。</p>
<h1 id="Reading-3"><a href="#Reading-3" class="headerlink" title="Reading 3"></a>Reading 3</h1><p><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2006/04/11/the-development-abstraction-layer-2/">The Development Abstraction Layer – Joel on Software</a></p>
<p><em>对于软件公司来说，管理的第一要务需要为程序员创造抽象。</em></p>
<hr>
<p>我认为Joel的看法是尽量不能让程序员分心，让大家能够各司其职，每个人都能拥有良好的工作环境。</p>
<p>创造抽象的目的就是让程序员专心于开发，发挥其长处，最终创造更好的软件，使用户受益。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/Online-Quiz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leonlist's Temporary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/23/Online-Quiz/" itemprop="url">Online_Quiz</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-23T15:58:54+08:00">
                2021-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h1><p>设计一个简单的在线考试系统</p>
<p>老师上传一个测验和考试学生列表。测验的格式是纯文本，主题题可附答案，主观题可附参考答案。系统将测验做出网页的格式，方便学生替换，填写。</p>
<p>老师可以批改每次测验每个同学的试卷。答题结果如果是主题题，则自动改分，如果是主观题，则老师手动改分。</p>
<p>老师可以下载每次测验所有同学的成绩。</p>
<p>学生可以登录答题（只有在学生列表中的学生才能答题）。</p>
<p>学生可以看到每次测验自己的分数以及做题详情。</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>在线考试系统的角色主要分两类：学生和老师。</p>
<p>学生的功能基本操作有：登录、在线考试、在考试后一段时间查看分数及对应题目的解析、修改个人信息。</p>
<p>学生功能模块有：学生主模块、考试模块、登录模块、个人信息模块</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生主模块 </span></span><br><span class="line">    —————— 考试管理</span><br><span class="line">    <span class="string">|   </span></span><br><span class="line">学生 —————— 登录</span><br><span class="line">    <span class="string">|</span></span><br><span class="line">    ——————  个人信息管理 </span><br><span class="line"></span><br><span class="line"><span class="comment">//学生考试模块       </span></span><br><span class="line">       —————— 查看考试</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       —————— 进行考试                 </span><br><span class="line">       <span class="string">|              </span></span><br><span class="line">考试模块—————— 提交试卷</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       —————— 查看分数</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       —————— 查看解析</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生登录模块</span></span><br><span class="line">登录模块———— 登录</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       ———— 找回密码   </span><br><span class="line"></span><br><span class="line"><span class="comment">//学生个人信息模块</span></span><br><span class="line">       ——————  上传头像</span><br><span class="line">       <span class="string">|   </span></span><br><span class="line">个人信息 —————— 修改密码</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       ——————  修改个人信息</span><br></pre></td></tr></table></figure>

<p>老师的基本操作有对学生信息、试卷信息、学生考试、老师信息等进行相应的增删改查工作。</p>
<p>老师功能模块有：老师主模块、学生信息管理模块、考试信息管理模块、试卷信息管理模块、老师用户信息模块</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老师主模块</span></span><br><span class="line">    —————— 学生信息管理</span><br><span class="line">    <span class="string">|</span></span><br><span class="line">    —————— 个人信息管理                </span><br><span class="line">    <span class="string">|              </span></span><br><span class="line">老师 —————— 考试信息管理</span><br><span class="line">    <span class="string">|</span></span><br><span class="line">    —————— 试卷信息管理</span><br><span class="line">    <span class="string">|</span></span><br><span class="line">    —————— 考试批阅管理</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012861467/article/details/54692236?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">超详细搭建PhpStorm+PhpStudy开发环境</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38191191/article/details/80458745?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-14.control&dist_request_id=1331973.6935.16185418682915173&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-14.control">版本管理（三）之phpstorm上传代码到GitHub</a></p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/10Ir5YDIOvm4ZOhFEBkUCNA">PHP和MySQL Web开发(原书第5版) 原版pdf+完整源码_密码：b93q</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/php/php-tutorial.html">PHP 教程|菜鸟教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/manual/thinkphp5/118003">ThinkPHP5.0</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/logo.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leonlist</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
