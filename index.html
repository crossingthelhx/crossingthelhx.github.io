<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Leonlist&#39;s Temporary Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Leonlist&#39;s Temporary Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Leonlist">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>Leonlist's Temporary Blog</title>
  








<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leonlist's Temporary Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">临时博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leonlist's Temporary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/24/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" itemprop="url">编译原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-24T14:38:57+08:00">
                2021-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h1><p><strong>终结符和非终结符</strong></p>
<p>终结符可以简单地理解为「推导到这里就终结了」，也就是说不能再继续通过生成式向下推倒的元素就是终结符。</p>
<p>比如 T-&gt;abc。T 推导为串 abc 后已经得到了实质上的字符，不用在向下推导了，那么 T 为非终结符，abc 无法继续推导，则为终结符。（在一系列生成式中，式子左边的一定是非终结符，从未出现在式子左边的一定是终结符）</p>
<p><strong>句子与句型</strong></p>
<p>如果符号串x是由起始符号推导出的，则称x是文法G[S]的句型。</p>
<p>如果x中只包含终结符，则称x是文法G[S]的句子。</p>
<p>文法描述的语言是该文法一切句子的集合。</p>
<p><strong>四种文法</strong></p>
<p>0型文法：α→β，其中α至少包含一个非终结符。</p>
<p>1型文法（上下文有关文法）：α→β，其中|β|≥|α|，S→ε除外。</p>
<p>2型文法（上下文无关文法）：a→β，其中a是一个非终结符。</p>
<p>3型文法（规范文法）：A→a或A→aB.</p>
<p>4种文法是逐渐增加限制的，所以规范文法一定是0型文法、1型文法、2型文法，上下文无关文法也一定是0型文法、1型文法…</p>
<p><strong>上下文有关文法与上下文无关文法</strong></p>
<p>在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。上下文无关指，只要文法的定义里有某个产生式，不管一个非终结符前后的串是什么，就可以应用相应的产生式进行推导。</p>
<p>上下文无关文法例子：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">产生式：</span><br><span class="line">Sent -&gt; S V O</span><br><span class="line">S -&gt; 人 | <span class="type">天</span></span><br><span class="line"><span class="type">V</span> -&gt; 吃 | <span class="type">下</span></span><br><span class="line"><span class="type">O</span> -&gt; 雨 | <span class="type">雪 | 饭 | 肉</span></span><br></pre></td></tr></table></figure>

<p>这个文法可以生成如下句子（共 16 种组合）：</p>
<p>｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝</p>
<p>可以看到，其中有一些搭配在语义上是不恰当的，例如”天吃肉“。其（最左）推导过程为：</p>
<p>Sent -&gt; SVO -&gt; 天VO -&gt; 天吃O -&gt; 天吃肉</p>
<p>而上下文有关文法例子如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Code</span><br><span class="line">Sent -&gt; S V O</span><br><span class="line">S -&gt; 人 | <span class="type">天</span></span><br><span class="line"><span class="type">人V</span> -&gt; 人吃</span><br><span class="line">天V -&gt; 天下</span><br><span class="line">下O -&gt; 下雨 | <span class="type">下雪</span></span><br><span class="line"><span class="type">吃O</span> -&gt; 吃饭 | <span class="type">吃肉</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里对 V 的推导过程施加了约束：虽然 V 还是能推出”吃“和”下“两个词，但是仅仅当 V 左边是”人“时，才允许它推导出”吃“；而当 V 左边是”天“时，允许它推导出”下“。这样通过上下文的约束，就保证了主谓搭配的一致性。类似地，包含 O 的产生式也约束了动宾搭配的一致性。（就是语法的强约束条件，导致上下文有关了）</p>
<p>这样一来，这个语言包含的句子就只有｛人吃饭，天下雨，人吃肉，天下雪｝这四条，都是语义上合理的。</p>
<p>以”人吃饭“为例，推导过程为：</p>
<p>Sent -&gt; SVO -&gt; 人VO -&gt; 人吃O -&gt; 人吃饭</p>
<p>（这与语法的歧义性还是不同的，要有所区分）</p>
<p><strong>1型文法比2型文法识别的语言集合更大？</strong></p>
<p>上例看到，感觉上下文有关文法所解释的句子集合更少。</p>
<p>这里的“1型文法比2型文法<strong>识别的语言集合</strong>更大” 这里的集合不是产生的结果集（字符串集合），而是语言规则集。 2型文法规则一定是1型文法规则，而有些语言能用1型文法规则描述，但用2型文法规则描述不出来。</p>
<h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><h3 id="最左推导-最右推导-规范句型"><a href="#最左推导-最右推导-规范句型" class="headerlink" title="最左推导/最右推导/规范句型"></a>最左推导/最右推导/规范句型</h3><p>例如 E+E   (i+i)：</p>
<ul>
<li>E+E =&gt; E+i =&gt; i+i  ——最右推导</li>
<li>E+E =&gt; i+E =&gt; i+i   ——最左推导</li>
</ul>
<p><strong>最左推导</strong>是指：任何一步α=&gt; β都是对α中的最左非终结符进行替换。</p>
<p>同样，可定义<strong>最右推导</strong>（又称规范推导）：任何一步α=&gt;β都是对α中的最右非终结符进行替换。</p>
<p>由规范推导所得到的句型称为<strong>规范句型</strong>。</p>
<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>一个文法的某个句子对应两棵不同的语法树，则这个文法是二义的。</p>
<p>或一个文法的某个句子有两个不同的最左（右）推导，则这个文法是二义的。</p>
<p>人们已证明，二义性问题是不可判定的，即不存在一个算法，它能在有限步骤内，确切地判断一个文法是否是二义的。（做题时就画两颗不同的语法树来证明其二义性）</p>
<h3 id="自上而下的分析法"><a href="#自上而下的分析法" class="headerlink" title="自上而下的分析法"></a>自上而下的分析法</h3><p>基本思想：从文法的开始符号出发，反复使用各种产生式，寻找“匹配”输入符号串的推导。即对任何输入符号串，从文法的开始符号（根结）出发，自上而下地为输入串建立一棵语法树，直到语法树结果正好是输入的符号串为止。</p>
<h3 id="自下而上的分析法"><a href="#自下而上的分析法" class="headerlink" title="自下而上的分析法"></a>自下而上的分析法</h3><p>基本思想：从输入串开始，逐步进行“归约”，直至归约到文法的开始符号。即从语法树的末端开始，步步向上“归约”，直到根结。</p>
<h3 id="短语、直接短语、句柄"><a href="#短语、直接短语、句柄" class="headerlink" title="短语、直接短语、句柄"></a>短语、直接短语、句柄</h3><ol>
<li><p><strong>短语</strong></p>
<p>令文法G，开始符号为S，αβδ是G的句型（即S=&gt;αβδ），如果S=&gt;αAδ且A=&gt;β，则称β是句型αβδ相对于非终结符A的短语。</p>
</li>
<li><p><strong>直接短语</strong></p>
<p>如短语中有A=&gt;β，则称β是句型相对于规则A→β的直接短语。</p>
</li>
<li><p><strong>句柄</strong></p>
<p>一个句型的最左直接短语称为该句型的句柄。</p>
</li>
</ol>
<p>⒈ 先证明前提</p>
<p>⒉ 给出语法树（注意文法是否是二义性的）</p>
<p>　如题文法G[E]:   E→ E+E|E*E|(E) | i</p>
<p>  证明i+i*i是G的一个句型，并指出这个句型的所有短语、直接短语、句柄。</p>
<p>⒊ 根据每棵语法树得出短语、直接短语、句柄</p>
<p>　（注意编号）</p>
<h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="NFA→-DFA的转换（NFA的确定化）"><a href="#NFA→-DFA的转换（NFA的确定化）" class="headerlink" title="NFA→ DFA的转换（NFA的确定化）"></a>NFA→ DFA的转换（NFA的确定化）</h2><h3 id="确定化的有关运算"><a href="#确定化的有关运算" class="headerlink" title="确定化的有关运算"></a>确定化的有关运算</h3><p><strong>（1）ε_closure(I) ——状态集合I的ε闭包(等价状态集)</strong></p>
<p> 设I是状态集的一个子集，ε_closure(I)定义为：</p>
<p>​    a.若S∈I，则S∈ε_closure(I)；</p>
<p>​    b. 若S∈I，那么从S出发经过任意ε弧而能到达的任意状态S’都属于ε_closure(I)；</p>
<p><strong>（2）Move(I, a)——状态集合I的a弧转换</strong></p>
<p> 假定I是状态集的一个子集，a是Σ中的一个字符，定义</p>
<p>​            Ia <strong>＝</strong> ε_closure(J)</p>
<p>其中J是所有那些可从I中的某一状态出发经过一条a弧而到达的状态结的全体。</p>
<p>　<strong>(3)Ia＝ ε_closure(Move(I, a))</strong></p>
<h3 id="子集化的具体过程"><a href="#子集化的具体过程" class="headerlink" title="子集化的具体过程"></a>子集化的具体过程</h3><p>为了方便起见，令Σ中只有a,b两个字母，即Σ＝{a, b}</p>
<p>（1）构造一张表，此表的每一行有三列，第一列为I，第二列为Ia，第二列为Ib。即</p>
<table>
<thead>
<tr>
<th align="center">I</th>
<th align="center">Ia</th>
<th align="center">Ib</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ε_closure(K0)</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>首先置该表的第一列为ε_closure(K0)</p>
<p>（2）一般而言，若某一行的第一列的状态子集已确定，例如记为I，则可以求出Ia和Ib</p>
<p>（3）检查Ia和Ib是否已在表的第一列中出现，把未曾出现者填入到后面空行的第一列位置上。</p>
<p>（4）对未重复Ia 、Ib的新行重复上述过程(2)、(3)，直到所有第二列和第三列的子集全部在第一列中出现</p>
<p><strong>DFA 的初态位该表第一行第一列的状态</strong></p>
<p><strong>DFA 的终态为含有原 NFA 的终态的状态子集</strong></p>
<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20210516181303298.png" alt="image-20210516181303298" style="zoom:67%;" />

<table>
<thead>
<tr>
<th>I</th>
<th>Ia</th>
<th>Ib</th>
<th>S</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>{0,1,2,4,7}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7}</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7,9}</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>{1,2,4,5,6,7}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7}</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>{1,2,4,5,6,7,9}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7,10}</td>
<td>3</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>{1,2,4,5,6,7,<strong>10</strong>}</td>
<td>{1,2,3,4,6,7,8}</td>
<td>{1,2,4,5,6,7}</td>
<td><strong>4</strong></td>
<td>1</td>
<td>2</td>
</tr>
</tbody></table>
<h2 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h2><ol>
<li>将得到的状态进行划分 ∏ ，划分为两部分，一部分为终态，一部分为为非终组。</li>
<li>继续进行划分，通过其可以匹配的字符进行判断，若该组内所有成员匹配字符都落在同一组内，即不可再分，否则重新划分组</li>
<li>若 ∏new = ∏ ，则进入步骤4，否则返回2</li>
<li>在分组 ∏new 每个组中选取一个状态作为代表，代表DFA的最简状态。</li>
</ol>
<h2 id="正规式→NFA"><a href="#正规式→NFA" class="headerlink" title="正规式→NFA"></a>正规式→NFA</h2><img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20210516193619828.png" alt="image-20210516193619828" style="zoom:67%;" />

<h1 id="自顶向下语法分析方法"><a href="#自顶向下语法分析方法" class="headerlink" title="自顶向下语法分析方法"></a>自顶向下语法分析方法</h1><p>对于任一输入符号串，从文法的识别符号出发，根据当前的输入符号，<strong>唯一的确定一个产生式</strong>，用产生式的右部的符号串替代相应的非终结符往下推导，或构造一棵语法树。若能推导出输入串或构造语法树成功则输入串是句子，否则不是。</p>
<h2 id="开始符号FIRST集合"><a href="#开始符号FIRST集合" class="headerlink" title="开始符号FIRST集合"></a>开始符号FIRST集合</h2><p><strong>理解</strong></p>
<p>FIRST(A)是以A开始符的集合，A的所有可能推导的开头终结符或者是ε</p>
<p><strong>例子</strong></p>
<ol>
<li><p>后面跟的不是非终结符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A-&gt;aB|ε</span><br><span class="line">A-&gt;c</span><br><span class="line">...</span><br><span class="line">First(A)&#x3D;&#123;a,ε,c&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后面跟非终结符（一）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A-&gt;Ba</span><br><span class="line">A-&gt;b</span><br><span class="line">...</span><br><span class="line">First(A)&#x3D;&#123;b&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后面跟的非终结符（二）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A-&gt;Bc</span><br><span class="line">B-&gt;b|ε</span><br><span class="line">...</span><br><span class="line">First(A)&#x3D;&#123;b,c&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后面跟的非终结符（三）</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">A-&gt;BC</span><br><span class="line">B-&gt;b|<span class="type">ε</span></span><br><span class="line"><span class="type">C</span>-&gt;c|<span class="type">ε</span></span><br><span class="line"><span class="type">...</span></span><br><span class="line"><span class="type">First</span>(A)=&#123;b,c,ε&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>构造文法G的每一文法符号X，X ∈ (VT∪VN)</p>
<ul>
<li><p>如果 X 是终结符号，那么FIRST(X)={X}</p>
</li>
<li><p>如果 X 是非终结符号，且 X -&gt; Y1Y2Y3…Yk 是产生式</p>
<ul>
<li>如果a在FIRST(Yi)中，且 ε 在FIRST(Y1)，FIRST(Y2)，…，FIRST(Yi-1)中，那么a也在FIRST(X)中；</li>
<li>如果ε 在FIRST(Y1)，FIRST(Y2)，…，FIRST(Yk)中，那么ε在FIRST(X)中；</li>
</ul>
</li>
<li><p>如果X是非终结符号，且有X-&gt;ε，那么ε在FIRST(X)中</p>
</li>
</ul>
<h2 id="后跟符号FOLLOW集合"><a href="#后跟符号FOLLOW集合" class="headerlink" title="后跟符号FOLLOW集合"></a>后跟符号FOLLOW集合</h2><p><strong>理解</strong></p>
<p>Follow(A)为非终结符A后跟符号的集合，Follow(A)是所有句型中出现在紧接A之后的终结符或’#‘</p>
<p><strong>求解规则</strong></p>
<p>将标记 # 放到 FOLLOW(S) 中</p>
<p>按照下面两个规则<strong>不断迭代</strong>，直到所有的 FOLLOW 集合都不再增长为止</p>
<ul>
<li>如果存在产生式 A -&gt; αBβ ，那么 FIRST(β) 中所有非 ε 的符号都在 FOLLOW(B) 中；</li>
<li>如果存在产生式 A -&gt; αB，或者 A -&gt; αBβ 且 FIRST(β) 包含 ε，那么 FOLLOW(A) 中的所有符号都加入到 FOLLOW(B) 中</li>
</ul>
<p><strong>理解求解规则</strong></p>
<ol>
<li><p>将标记 # 放到 FOLLOW(S) 中</p>
</li>
<li><p>形如A -&gt; αBβ</p>
<p>（α可以是终结符或者非终结符或者直接为空，β可以是终结符或者非终结符，注意β不能为空，B后面要有东西）</p>
<p>比如</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B</span><br><span class="line">A-&gt;cB</span><br><span class="line"></span><br><span class="line">A-&gt;dBC</span><br><span class="line">C-&gt;ε</span><br></pre></td></tr></table></figure>

<p>那么 FOLLOW(A) 中的所有符号都加入到 FOLLOW(B) 中</p>
<p><strong>例子一</strong></p>
<p>注意：[if] 是一个终结符，同理[b] [other] [else] [then]</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">G(S)：S-&gt;IETSP|<span class="type">O</span></span><br><span class="line">I-&gt;<span class="keyword">if</span></span><br><span class="line">E-&gt;b</span><br><span class="line">O-&gt;other</span><br><span class="line">L-&gt;<span class="keyword">else</span></span><br><span class="line">T-&gt;<span class="keyword">then</span></span><br><span class="line">P-&gt;LS|<span class="type">ε</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>First</strong></th>
<th><strong>Follow</strong></th>
</tr>
</thead>
<tbody><tr>
<td>First(S)={if,other}</td>
<td>Follow(S)={井号 ,else}</td>
</tr>
<tr>
<td>First(I)={if}</td>
<td>Follow(I)={b}</td>
</tr>
<tr>
<td>First(E)={b}</td>
<td>Follow(E)={then}</td>
</tr>
<tr>
<td>First(O)={other}</td>
<td>Follow(O)={else,井号}</td>
</tr>
<tr>
<td>First(L)={else}</td>
<td>Follow(L)={if,other}</td>
</tr>
<tr>
<td>First(P)={else,ε}</td>
<td>Follow(P)={else,井号}</td>
</tr>
<tr>
<td>First(T)={then}</td>
<td>Follow(T)={if,other}</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Select集合"><a href="#Select集合" class="headerlink" title="Select集合"></a>Select集合</h2><p><strong>理解</strong></p>
<ol>
<li>如果a不能=&gt;ε，则 Select(A-&gt;a)=First(a)</li>
<li>如果a=&gt;ε，则 Select(A-&gt;a)=(First(a)-{ε})UFollow(A)</li>
</ol>
<h2 id="LL-1-文法的判别"><a href="#LL-1-文法的判别" class="headerlink" title="LL(1) 文法的判别"></a>LL(1) 文法的判别</h2><h3 id="满足定义"><a href="#满足定义" class="headerlink" title="满足定义"></a>满足定义</h3><ol>
<li>求出能推出ε的非终结符</li>
<li>求FIRST集合；</li>
<li>求FOLLOW集合；</li>
<li>计算SELECT集合。</li>
<li>对同一非终结符的不同产生式求Select交集</li>
</ol>
<h2 id="某些非LL-1-文法到LL-1-文法的等价转换"><a href="#某些非LL-1-文法到LL-1-文法的等价转换" class="headerlink" title="某些非LL(1)文法到LL(1)文法的等价转换"></a>某些非LL(1)文法到LL(1)文法的等价转换</h2><h3 id="存在左公因子"><a href="#存在左公因子" class="headerlink" title="存在左公因子"></a>存在左公因子</h3><p>解决方法：提取左公因子</p>
<p>若文法中存在形如：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;ay|<span class="type">ab</span>   </span><br><span class="line">两个产生式左部第一个符号相同，则不符合LL（<span class="number">1</span>）文法，指代不明，则表示存在左公因子</span><br><span class="line"></span><br><span class="line">解决方法：</span><br><span class="line">转换成 A-&gt;aM1,aM2，aM3....的形式：</span><br><span class="line">得：</span><br><span class="line">A-&gt;aM</span><br><span class="line">M-&gt;y|<span class="type">b</span></span><br><span class="line">则成功提取左公因子；</span><br></pre></td></tr></table></figure>

<h3 id="存在左递归"><a href="#存在左递归" class="headerlink" title="存在左递归"></a>存在左递归</h3><p><strong>（1）直接左递归</strong> </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>-&gt;AB, <span class="selector-tag">A</span>∈Vn，<span class="selector-tag">B</span>属于V*</span><br></pre></td></tr></table></figure>

<p>方法：左递归变右递归</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;β1P&#x27;|<span class="string">β2P&#x27;</span>|<span class="string">…</span>|<span class="string">βnP&#x27;</span></span><br><span class="line"><span class="string">P&#x27;-&gt;α1P&#x27;</span>|<span class="string">α2P&#x27;</span>|<span class="string">…</span>|<span class="string">αmP&#x27;</span>|<span class="string">ε</span></span><br></pre></td></tr></table></figure>

<p>例：给定文法G(S):</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E-&gt;E+T|<span class="type">T</span></span><br><span class="line">T-&gt;T*F|<span class="type">F</span></span><br><span class="line">F-&gt;(E)|<span class="type">i</span></span><br></pre></td></tr></table></figure>

<p>消除其直接左递归G(E):</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E-&gt;T<span class="string">E&#x27;</span></span><br><span class="line"><span class="string">E&#x27;</span>-&gt;+T<span class="string">E&#x27;|ε</span></span><br><span class="line"><span class="string">T-&gt;FT&#x27;</span></span><br><span class="line">T<span class="string">&#x27;-&gt;*FT&#x27;</span>|ε</span><br><span class="line">F-&gt;(E)|i</span><br></pre></td></tr></table></figure>



<p><strong>（2）间接左递归</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>-&gt;Bb</span><br><span class="line"><span class="selector-tag">B</span>-&gt;Aa</span><br><span class="line"><span class="selector-tag">A</span>,<span class="selector-tag">B</span>∈Vn，<span class="selector-tag">a</span>，<span class="selector-tag">b</span>属于V*</span><br></pre></td></tr></table></figure>

<p>（这里第二种情况注意，因为是左递归，所以看得就是第一个字符，一定要跟这个类型一样的A-&gt;B…. 以及B-&gt;A…. 这种才是左递归，如果A-&gt;B…. ,B-&gt;aA…,  这种就不是左递归了，因为样式不同，请注意）</p>
<p>同样消除左递归的方法：</p>
<p>如果是间接左递归，则先转换成直接左递归：</p>
<p>例子：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;Bb | <span class="type">c</span></span><br><span class="line">B-&gt;Aa</span><br></pre></td></tr></table></figure>

<p>将B-&gt;Aa代入到另一个式子：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;Aab | <span class="type">c</span></span><br></pre></td></tr></table></figure>

<p>转换</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;cM</span><br><span class="line">M-&gt;abM</span><br><span class="line">M-&gt;ε</span><br></pre></td></tr></table></figure>

<h1 id="自底向上优先分析"><a href="#自底向上优先分析" class="headerlink" title="自底向上优先分析"></a>自底向上优先分析</h1><h2 id="算符优先文法"><a href="#算符优先文法" class="headerlink" title="算符优先文法"></a>算符优先文法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>算符优先分析法(Operator Precedence Parse)是仿效四则运算的计算过程而构造的一种语法分析方法。算符优先分析法的关键是比较两个相继出现的终结符的优先级而决定应采取的动作。</p>
<p>优点：简单，有效，适合表达式的分析。</p>
<p>缺点：只适合于算符优先文法，是一个不大的文法类。</p>
<h3 id="算符优先关系的定义"><a href="#算符优先关系的定义" class="headerlink" title="算符优先关系的定义"></a>算符优先关系的定义</h3><ul>
<li>a &lt; b 文法中有形如 A→…aB… 的产生式而 B=&gt;b… 或 B=&gt;Cb…</li>
<li>a &lt; b 文法中有形如 A→…ab… 或 A=&gt;…aBb… 的产生式</li>
<li>a &gt; b 文法中有形如 A→…Bb… 的产生式而 B=&gt;…a 或 B=&gt;…aC</li>
</ul>
<h3 id="FIRSTVT和LASTVT的构造规则"><a href="#FIRSTVT和LASTVT的构造规则" class="headerlink" title="FIRSTVT和LASTVT的构造规则"></a>FIRSTVT和LASTVT的构造规则</h3><p><strong>Firstvt</strong><br>找Firstvt的三条规则：如果要找A的Firstvt，A的候选式中出现：</p>
<ul>
<li>A-&gt;a…，即以终结符开头，该终结符入Firstvt</li>
<li>A-&gt;B…，即以非终结符开头，该非终结符的Firstvt入A的Firstvt</li>
<li>A-&gt;Ba…，即先以非终结符开头，紧跟终结符，则终结符入Firstvt</li>
</ul>
<p><strong>Lastvt</strong><br>找Lastvt的三条规则：如果要找A的Lastvt，A的候选式中出现：</p>
<ul>
<li>A-&gt;…a，即以终结符结尾，该终结符入Lastvt</li>
<li>A-&gt;…B，即以非终结符结尾，该非终结符的Lastvt入A的Lastvt</li>
<li>A-&gt;…aB，即先以非终结符结尾，前面是终结符，则终结符入Firstvt</li>
</ul>
<h3 id="构造算法优先关系表"><a href="#构造算法优先关系表" class="headerlink" title="构造算法优先关系表"></a>构造算法优先关系表</h3><ul>
<li><p>a=b 关系</p>
<p>可直接查看产生式的右部，对如下形式的产生式</p>
<p>A-&gt;…ab…</p>
<p>A-&gt;…aBb…</p>
<p>则有 a=b 成立</p>
</li>
<li><p>a&lt;b 关系</p>
<p>对于所给表达式文法中终结符在前，非终结符在后的所有相邻符号对，有 b 属于FIRSTVT(B)，则 a&lt;b 成立</p>
<p>a&lt;FIRSTVT()</p>
</li>
<li><p>a&gt;b 关系</p>
<p>对于所给表达式文法中非终结符在前，终结符在后的所有相邻符号对，有 a 属于FIRSTVT(B)，则 b&gt;a 成立</p>
<p>LASTVT()&gt;a</p>
</li>
</ul>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><p>素短语</p>
<p>文法G某句型的一个短语是素短语，当且仅当它至少含有一个终结符，且除它自身之外不再含更小的素短语。</p>
</li>
<li><p>最左素短语</p>
<p>在具有多个素短语的句型中处于最左边的那个素短语</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/09/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leonlist's Temporary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/09/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" itemprop="url">软件项目管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-09T19:17:28+08:00">
                2021-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Reading-1"><a href="#Reading-1" class="headerlink" title="Reading 1"></a>Reading 1</h1><p><a href="https://link.zhihu.com/?target=http://www.joelonsoftware.com/articles/fog0000000069.html">Things You Should Never Do, Part I</a></p>
<p>这是国外的老程序员 Joel Spolsky 在2000年写的文章。</p>
<p>更详尽的带图表的分析:</p>
<p><a href="https://link.zhihu.com/?target=http://vibratingmelon.com/2011/06/10/why-you-should-almost-never-rewrite-code-a-graphical-guide/">Why You Should (Almost) Never Rewrite Code – A Graphical Guide</a></p>
<hr>
<p>Avram Joel Spolsky生于1965年，他是一位软件工程师和作家。他是“Joel on Software”博客的作者。他从1991年到1994年间担任Microsoft Excel团队的项目经理。在2000年，他创立了Fog Creek软件并开启了“<a target="_blank" rel="noopener" href="http://www.joelonsoftware.com/index.html">Joel on Software</a>”博客。2008年，他和Jeff Atwood一起启动了如今极为成功的Stack Overflow程序员问答网站。他们用Stack Exchange软件产品作为<a target="_blank" rel="noopener" href="http://stackoverflow.com/">Stack Overflow</a>的引擎。现如今<a target="_blank" rel="noopener" href="http://stackexchange.com/">Stack Exchange</a>网络已经包含了91个站点。</p>
<hr>
<p>他在这篇文章的论点来源于一个简单的事实：<br><strong>It’s harder to read code than to write it.</strong><br><strong>写代码容易，读代码难。</strong></p>
<p>在开头，他批评网景公司<strong>犯了的最严重的战略错误</strong>——<strong>他们决定从头开始重写代码</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于网景当时的极度成功，公司规模扩展很快，为了应对开发的需求而收购了一家大型软件开发公司。但这家被收购公司的高层以及开发人员做了一系列愚蠢决定，包括使用当时如麻花一般的 <span class="built_in">C</span><span class="operator">++</span> 代替 <span class="built_in">C</span>，削减支持平台，优先发布 <span class="variable">Windows</span> 版本浏览器等，最后造成了新版本发布遥遥无期，程序质量不高等一系列问题，失去了对其他浏览器（包括<span class="variable">IE</span>）功能上和性能上的绝对优势，而结果就是被用户抛弃。</span><br></pre></td></tr></table></figure>

<p>作者的观点主要有：</p>
<ol>
<li>重写的代码即便能完全达到旧代码的所有功能、性能需求，为产品带来的竞争力也只有边际提升。（这个很好理解，因为代码的规范性和清晰度对产品的功能性没有直接帮助，只能降低远期的维护成本）</li>
<li>由于重写代码过程中需要花费额外的钱和时间，可能会出现一些意外状况，比如预算不够了，核心程序员离职了，或是重写的产品没有达到原有产品的所有功能和性能需求，那么这个结果可能是灾难性的，重写的产品要么胎死腹中，要么市场竞争力反而更低了。</li>
<li>在重写期间，由于竞争对手不会停滞不前并且您无法开发新功能，因此产品的竞争力通常会下降。而且重写花费的时间比预期的要长得多，连锁效应使产品竞争力下降的时间更长。对于小公司来说，这可能是致命的。</li>
</ol>
<p>上面三个中的任何一个都可能致命，但是所有三个问题肯定都是致命的，产品的竞争力可能永远不会恢复。</p>
<p>如果公司的项目或产品代码混乱到无法再加入新功能或提升性能，跟时代严重脱节怎么办，那么应用以上原则，这时候既然这个项目已经快死了，那么放到新项目里重写显然是最合理的选择。</p>
<h1 id="Reading-2"><a href="#Reading-2" class="headerlink" title="Reading 2"></a>Reading 2</h1><p>同样是 Joel Spolsky 在2000年写的文章。</p>
<p><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2000/08/09/the-joel-test-12-steps-to-better-code/">The Joel Test: 12 Steps to Better Code</a></p>
<hr>
<p>他用这十二条来评估软件团队的质量，大多数软件组织的运行得分为2或3，像 Microsoft 这样的公司的得分为12。</p>
<ol>
<li>Do you use source control?</li>
<li>Can you make a build in one step?</li>
<li>Do you make daily builds?</li>
<li>Do you have a bug database?</li>
<li>Do you fix bugs before writing new code?</li>
<li>Do you have an up-to-date schedule?</li>
<li>Do you have a spec?</li>
<li>Do programmers have quiet working conditions?</li>
<li>Do you use the best tools money can buy?</li>
<li>Do you have testers?</li>
<li>Do new candidates write code during their interview?</li>
<li>Do you do hallway usability testing?</li>
</ol>
<hr>
<p><strong>1.您是否使用源代码管理？</strong></p>
<p>如果您没有源代码控制，那么您将不得不尝试使程序员们一起工作。程序员无法知道其他人做了什么。错误不能轻易回滚。</p>
<p>在源代码层面使其易于管理、维护，同时降低核心技术泄密风险。</p>
<p><strong>2.你们可以把整个系统从源码到CD映像文件一步建成吗？</strong></p>
<p>这句话问的问题是：从你们最新的源码开始到建立起能够交出去的最后文件，你们有多少步骤要做？ 一个好的团队应该有一个批处理程序一步便可将所有的工作做完，像把源文件提取出来，跟据不同的语言版本要求（英文版，中文版），和各种编译开关（#ifdef）进行编译，联接成可执行文件，标上版本号，打包成CD映像文件或直接送到网站上去，等等等等。</p>
<p><strong>3.您是否进行日常构建？</strong></p>
<p>在微软软件开发中，每日构建是最重要的过程之一，被称为微软产品开发的“心跳”。简单来看，每天构建系统将整个产品解决方案完整构建一遍，生成的目标文件和安装文件被放置在一个共享位置。接着，安装文件被自动部署到release server上，随后可以自动运行BVT（build verification test），并将所有结果寄送每个team member的信箱。</p>
<p><strong>4.您是否有 bug 数据库？</strong></p>
<p>如果您正在开发代码，即使是一个团队，也没有列出代码中所有已知错误的有组织的数据库，那么您将交付低质量的代码。</p>
<p><strong>5.在编写新代码之前，您是否修复了 bug？</strong></p>
<p>要立即修复 bug 的原因之一：因为它花费的时间更少。还有另一个原因，这与以下事实有关：预测编写新代码要比修复现有 bug 要花多长时间。例如，如果我要求您预测编写代码以对列表进行排序所需的时间，那么您可以给我一个很好的估计。但是，如果我问你如何预测这将需要多长时间来修复 bug：如果安装Internet Explorer 5.5您的代码不工作，你甚至无法猜测的，因为你不知道（定义）是什么导致 bug。跟踪可能需要3天，或者可能需要2分钟。</p>
<p>这意味着如果您的日程安排中有许多尚待修复的 bug，则该日程安排是不可靠的。但是，如果您已经解决了所有已知的 bug，而剩下的只是新代码，那么您的日程安排将更加准确。</p>
<p>将 bug 计数保持为零的另一个很棒的事情是，您可以更快地响应竞争。一些程序员认为这是使产品随时准备就的准备*。然后，如果您的竞争对手推出了一种吸引用户的杀手级新功能，则您可以实施该功能并当场发货，而无需修复大量累积的 bug。</p>
<p><strong>6.您有最新的时间表吗？</strong></p>
<p>这使我们按计划进行。如果您的代码对企业至关重要，则有很多原因说明知道何时完成代码对企业很重要。</p>
<p>制定时间表的另一个关键之处在于，它迫使您决定要执行的功能，然后迫使您选择最不重要的功能并将其剪切掉，而不是陷入特征<a target="_blank" rel="noopener" href="http://www.netmeg.net/jargon/terms/c/creeping_featuritis.html">成熟度</a>（又称范围蠕动）。</p>
<p><strong>7.您有写软件规格说明书（SPEC）吗？</strong></p>
<p>在产品的前期设计过程中，如果你发现了一些问题，你可以轻易地在说明书里该几行字就行了。一旦进入了写程序的阶段，解决问题的代价就要高得多了。</p>
<p>没有产品开发详细说明书就开始写程序，往往会导致程序写的乱七八糟，而且左拖右拖不能交付使用。</p>
<p>不论采用以上哪种方法，道理只有一个：在没有产品开发详细说明书之前，决不可写程序。</p>
<p><strong>8.程序员有安静的工作条件吗？</strong></p>
<p>通过为知识工作者提供空间，安静和私密性，可以广泛地记录生产率的提高。</p>
<p><strong>9.您是否使用金钱可以买到的最好的工具？</strong></p>
<p>要给予程序员尽可能好的条件</p>
<p><strong>10.您有测试员吗？</strong></p>
<p>需要有测试员来检测产品的漏洞</p>
<p><strong>11.新候选人在面试中是否写代码？</strong></p>
<p>通过写代码了解程序员的能力，而不是看似漂亮的简历和问几个简单的问题（如CreateDialog()和DialogBox()有什么区别？这种问题，查一下帮助文件就知道了）</p>
<p><strong>12.您是否进行走廊可用性测试？</strong></p>
<p>也就是随便抓一个人来，进行测试。</p>
<p>走廊实用性测试对于企业产品测试来讲提供的反馈比招募来做测试得出的结论要好很多，而且很多时候是完全相反的结论。</p>
<p>但现在很多企业都不做走廊测试了，而改用poll这种电子方式在Social Media发布，让用户选择。原因是走廊测试这种方法的效率不高。</p>
<h1 id="Reading-3"><a href="#Reading-3" class="headerlink" title="Reading 3"></a>Reading 3</h1><p><a target="_blank" rel="noopener" href="https://www.joelonsoftware.com/2006/04/11/the-development-abstraction-layer-2/">The Development Abstraction Layer – Joel on Software</a></p>
<p><em>对于软件公司来说，管理的第一要务需要为程序员创造抽象。</em></p>
<hr>
<p>我认为Joel的看法是尽量不能让程序员分心，让大家能够各司其职，每个人都能拥有良好的工作环境。</p>
<p>创造抽象的目的就是让程序员专心于开发，发挥其长处，最终创造更好的软件，使用户受益。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/23/Online-Quiz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leonlist's Temporary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/23/Online-Quiz/" itemprop="url">Online_Quiz</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-23T15:58:54+08:00">
                2021-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="项目内容"><a href="#项目内容" class="headerlink" title="项目内容"></a>项目内容</h1><p>设计一个简单的在线考试系统</p>
<p>老师上传一个测验和考试学生列表。测验的格式是纯文本，主题题可附答案，主观题可附参考答案。系统将测验做出网页的格式，方便学生替换，填写。</p>
<p>老师可以批改每次测验每个同学的试卷。答题结果如果是主题题，则自动改分，如果是主观题，则老师手动改分。</p>
<p>老师可以下载每次测验所有同学的成绩。</p>
<p>学生可以登录答题（只有在学生列表中的学生才能答题）。</p>
<p>学生可以看到每次测验自己的分数以及做题详情。</p>
<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>在线考试系统的角色主要分两类：学生和老师。</p>
<p>学生的功能基本操作有：登录、在线考试、在考试后一段时间查看分数及对应题目的解析、修改个人信息。</p>
<p>学生功能模块有：学生主模块、考试模块、登录模块、个人信息模块</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生主模块 </span></span><br><span class="line">    —————— 考试管理</span><br><span class="line">    <span class="string">|   </span></span><br><span class="line">学生 —————— 登录</span><br><span class="line">    <span class="string">|</span></span><br><span class="line">    ——————  个人信息管理 </span><br><span class="line"></span><br><span class="line"><span class="comment">//学生考试模块       </span></span><br><span class="line">       —————— 查看考试</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       —————— 进行考试                 </span><br><span class="line">       <span class="string">|              </span></span><br><span class="line">考试模块—————— 提交试卷</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       —————— 查看分数</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       —————— 查看解析</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生登录模块</span></span><br><span class="line">登录模块———— 登录</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       ———— 找回密码   </span><br><span class="line"></span><br><span class="line"><span class="comment">//学生个人信息模块</span></span><br><span class="line">       ——————  上传头像</span><br><span class="line">       <span class="string">|   </span></span><br><span class="line">个人信息 —————— 修改密码</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       ——————  修改个人信息</span><br></pre></td></tr></table></figure>

<p>老师的基本操作有对学生信息、试卷信息、学生考试、老师信息等进行相应的增删改查工作。</p>
<p>老师功能模块有：老师主模块、学生信息管理模块、考试信息管理模块、试卷信息管理模块、老师用户信息模块</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//老师主模块</span></span><br><span class="line">    —————— 学生信息管理</span><br><span class="line">    <span class="string">|</span></span><br><span class="line">    —————— 个人信息管理                </span><br><span class="line">    <span class="string">|              </span></span><br><span class="line">老师 —————— 考试信息管理</span><br><span class="line">    <span class="string">|</span></span><br><span class="line">    —————— 试卷信息管理</span><br><span class="line">    <span class="string">|</span></span><br><span class="line">    —————— 考试批阅管理</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012861467/article/details/54692236?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5.control">超详细搭建PhpStorm+PhpStudy开发环境</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38191191/article/details/80458745?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-14.control&dist_request_id=1331973.6935.16185418682915173&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-14.control">版本管理（三）之phpstorm上传代码到GitHub</a></p>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/10Ir5YDIOvm4ZOhFEBkUCNA">PHP和MySQL Web开发(原书第5版) 原版pdf+完整源码_密码：b93q</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/php/php-tutorial.html">PHP 教程|菜鸟教程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/manual/thinkphp5/118003">ThinkPHP5.0</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/logo.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leonlist</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
