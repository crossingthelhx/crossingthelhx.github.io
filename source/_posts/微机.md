---
title: 微机
date: 2021-05-26 11:17:15
tags:
---

# 微机原理与汇编语言

教材《微型计算机原理与接口技术》

内容主要以8086为主要对象，包括微型计算机的基础知识、8086CPU、寻址方式、指令系统、汇编语言程序设计和存储器。



## 微型计算机的基础知识和发展状况

- 进制转换、原码、反码、补码
- 冯·诺依曼计算机结构
- 微型计算机基本结构



## 微处理器的结构和工作模式

### 8086 CPU基本结构

### 8086 CPU内部寄存器

- 数据寄存器
  - AX 累加器
  - BX 基地址指针，存放偏移地址
  - CX 计数寄存器
  - DX 数据寄存器
- 地址指针和变址寄存器
  - SP 堆栈指针
  - BP 基址指针
  - SI 源变址寄存器
  - DI 目的变址寄存器
  - BX 基址寄存器
- 段寄存器
  - CS 代码段寄存器
  - DS 数据段寄存器
  - SS 堆栈段寄存器
  - ES 附加段寄存器
- 指令指针 IP
- 标志寄存器 FLAGS
  - CF 进位标志
  - PF 奇偶校验标志
  - AF 辅助进位标志
  - ZF 零标志
  - SF 符号标志
  - OF 溢出标志
  - TF 陷阱标志
  - IF 中断标志
  - DF 方向标志

- 8086 CPU的引脚功能
  - AD15~AD0，地址/数据总线，双向、三态、分时复用信号
  - A19/S6~A16/S3，地址/状态线
  - RD 读控制信号
  - WR 写控制信号
  - 
- 8086 CPU的存储器组织
- 最小模式系统
- 总线操作时序



## 8086 的寻址方式和指令系统

### 8086 的寻址方式

- **立即寻址方式**

  立即数作为源操作数

- **寄存器寻址方式**

  操作数包含在寄存器中，由指令指定寄存器的名称

  注意：源操作数的长度必须与目的操作数一致，比如不能把AH的内容传送到CX中

- 存储器寻址方式
  - **直接寻址方式**
  
    物理地址=16*DS+EA，默认为DS为基地址，EA上必须加方括号，与立即数区分
  
    （段超越前缀）ES:[500H]，以ES作基地址
  
    可以用符号地址代替数值地址，实际上就是给存储单元起一个名字
  
  - **寄存器间接寻址方式**
  
    源操作数的寄存器的值为操作数的有效地址，寄存器名称外必须加方括号
  
    如果指令中指定的寄存器为BX、SI、DI，段地址为数据段DS
  
    如果为BP，段地址为堆栈段SS
  
    MOV BX，[SI]
  
    允许段超越前缀
  
  - **寄存器相对寻址方式**
  
    与寄存器间接寻址类似，就是在有效地址上加一个位移量
  
    MOV BX, COUNT[SI]，位移量COUNT
  
    也允许段超越前缀
  
    MOV DH, ES:ARRAY[SI]
  
  - **基址变址寻址方式**
  
    操作数的有效地址为一个基址寄存器（BX或BP）和一个变址寄存器（SI和DI）的内容之和
  
    MOV AX, [BX+SI]    物理地址=16*DS+BX+SI
  
    基址寄存器为BX时，段址寄存器为DS；基址寄存器为BP时，段寄存器为SS
  
  - **相对基址变址寻址方式**
  
    操作数的有效地址为一个基址寄存器（BX或BP）和一个变址寄存器（SI和DI）的内容，再加上指令中指定的8位或16为位移量之和。
  
    就是在基址变址寻址方式上加上位移量
  
- 其他寻址方式
  - 隐含寻址
  - I/O 端口寻址
  - 一条指令作几种寻址方式
  - 转移类指令寻址

### 机器语言指令编码格式

### 8086 指令系统

- **MOV 传送指令**

  IP 寄存器不能用作源操作数或目的操作数

  立即数和CS 寄存器不能用作目的操作数

  MOV 指令不能在两个存储单元之间直接传送数据，也不能在两个段寄存器之间直接传送数据

- **PUSH 进栈指令**

  源操作数可以是16位通用寄存器、段寄存器或存储器中的数据字，但不能是立即数

- **POP 出栈指令**

  源操作数可以是16位通用寄存器、段寄存器或存储单元，但CS不能用作目的操作数

- **XCHG 交换指令**

  XCHG 目的， 源     把源操作数和目的操作数相交换

  交换可以在寄存器之间、寄存器和存储器之间，但段寄存器不能作为操作数，也不能直接交换两个存储单元之间的内容

- **XLAT 表转换指令**

- **IN 输入指令**

- **LEA 取有效地址指令**

  LEA 目的， 源

  取源操作数地址的偏移量，并把它传送目的操作数所在单位

  源操作数必须是存储单元，而且目的操作数必须是一个除段寄存器之外的16位寄存器

- **LDS将双字指针送到寄存器和DS指令**

  LDS 目的， 源

  从源操作数指定的存储单元中，取出一个变量的4字节地址指针，送进一对目的寄存器

  指令中源操作数必须是存储单元，从该存储单元开始的连续4个字节单元 中，存放着一个变量的地址指针。目的操作数必须是16位寄存器，通常使用SI寄存器，但是不能使用段寄存器

- **LES将双字指针送到寄存器和ES指令**

  LES 目的， 源

  与LDS指令操作基本相同，不同是将源操作数所指向的地址指针中的段地址部分送到ES寄存器中，而不是DS寄存器，目的操作数常用DI寄存器

- **LAHF 标志送到 AH 指令**

  把标志寄存器SF、ZF、AF、PF和CF分别传送到AH寄存器位7，6，4，2和0

- **SAHF AH送标志寄存器**

  把AH内容存入标志寄存器

- **PUSHF 标志入栈指令**

- **POPF 标志出栈指令**

- **ADD 加法指令**

- **ADC 带进位的加法指令**

  在两个操作数相加的同时，还要把进位标志CF 的当前值加进去作为和，再把结果送到目的操作数中

- **INC 增量指令**

  INC 目的

  对目的操作数加一

- **AAA 加法的ASCII调整指令**

- **DAA 加法的ASCII调整指令**

- **SUB 减法指令**

- **SBB 带借位的减法指令**

- **NEG 取负指令**

- **CMP 比较指令**

  将目的操作数减去源操作数，但仅将结果反映在标志位上

- **AAS 减法的ASCII调整指令**

- **DAS 减法的十进制调整指令**

- **MUL 无符号数乘法指令**

- **IMUL 整数乘法指令**

- **DIV 无符号数除法指令**

- **IDIV 整数除法指令**

- **CBW 把字节转换为字指令**

  将寄存器AL中字节的符号位扩充到AH的所有位

- **CWD 把字转换成双字指令**

  把AX中的字的符号位扩充到DX寄存器的所有位中去

- **AAD 除法的ASCII调整指令**

- **NOT取反指令**

  将目的操作数求反

  目的操作数可以是8位或16位寄存器或存储器，指令执行后，对标志位无影响

- **AND 逻辑与指令**

  对两个操作数进行按位逻辑与操作，结果返回目的操作数

- **OR 逻辑或指令**

  对两个操作数进行按位逻辑或操作，结果返回目的操作数

- **XOR 异或操作指令**

  对两个操作数进行按位逻辑异或运算，结果返回目的操作数

- **TEST 测试指令**

  对两个操作数进行按位逻辑与操作，并修改标志位，但不回送结果

- **SAL 算术左移指令**

- **SHL 逻辑左移指令**

  上面两条指令的功能完全相同，每移动一次，最低有效位LSB补0，最高有效位MSB进入标志位CF

- **SHR 逻辑右移指令**

  最高位补0

- **SAR 算数右移指令**

  最高位（符号位）保持不变

- **ROL 循环左移指令**

- **ROR 循环右移指令**

- **RCL 通过进位位循环左移指令**

- **RCR 通过进位位循环右移指令**

- **MOVS 字符串传送指令**

  REP MOVSB 等价于

  MOVS NEW_LOC, SRC_MESS

  ​			DEC CX

  ​			 JNZ AGAIN

- **CMPS 字符串比较指令**

- **SCAS 字符串扫描指令**

- **LODS 数据串装入指令**

- **STOS 数据串存储指令**

  将累加器AL或AX中的一个字节或字，传送到附加段中以DI为目标指针的目的串中，同时修改DI，以2指向串中的下一个单元

- **JMP 无条件转移指令**

  使程序无条件的转移到指令中的目的地址去执行

- 





# 复习题

## 第三章

1. **寻址方式？**

   寄存器间接寻址、直接寻址、寄存器相对寻址、基址加变址寻址、基址加变址相对寻址。

2. **数据操作数的种类？**

   立即数、寄存器数和内存单元数

3. **段地址、偏移地址与物理地址之间的关系？有效地址EA又是指什么？**

   段地址左移四位加上偏移地址形成20位的物理地址。EA是指段内偏移地址，即表示段内某单元相对于段起始地址的空间位置。

4. **能用于寄存器间接寻址及变址寻址的寄存器有哪些？它们通常与哪个段寄存器配合形成物理地址？**

   基址寄存器BX和BP，变址寄存器SI和DI

   BX、SI、DI与DS配合形成物理地址，而BP与SS配合形成物理地址。

5. **什么是堆栈操作？**

   堆栈被定义为一种先进后出的数据结构，即最后进栈的元素将被最先弹出来。堆栈从一个称为栈底的位置开始，数据进入堆栈的操作称为压入（或压栈），数据退出堆栈的操作称为弹出，每进行一次弹出操作，堆栈就减少一个元素，最后一次压入的元素，称为栈顶元素，压入弹出操作都是对栈顶元素进行的堆栈的两种基本的操作。

6. **用汇编语言指令实现以下操作**

   **(1)将寄存器AX、BX和DX的内容相加，和放在寄存器DX中。**

   `ADD AX，BX`

   `ADD DX，AX`

   **(2)用基址变址寻址方式（BX和SI）实现AL寄存器的内容和存储器单元BUF中的一个字节相加的操作，和放到AL中。**

   `ADD AL，BYTE PTR [BX][SI]`

   **(3)用寄存器BX实现寄存器相对寻址方式（位移量为100H），将DX的内容和存储单元中的一个字相加，和放到存储单元中。**

   `ADD 100H[BX]，DX`

   **(4)用直接寻址方式（地址为0500H）实现将存储器中的一个字与立即数3ABCH相加，和放回该存储单元中。**

   `ADD [0500H]，3ABCH`

   **(5)用串操作指令实现将内存定义好的两个字节串BUF1和BUF2相加后的和，存放到另一个串BUF3中的功能。**

   ```
   ……
   MOV CX, COUNT
   MOV SI, OFFSET BUF1
   MOV DI, OFFSET BUF3
   MOV BX, OFFSET BUF2
   AGAIN: LODSB ;取[DS]:SI中的字节
   ADD AL, [BX] ;与[DS]:BX中的字节相加
   STOSB     ;存入[ES]:DI中
   INC BX
   DEC CX
   JNZ AGAIN
   ……
   ```

7. **指出下列指令中，源操作数及目的操作数的寻址方式。**

   SUB BX，[BP+35]  ；寄存器寻址、寄存器相对寻址

   MOV AX，2030H  ；寄存器寻址、立即寻址

   SCASB        ；隐含操作数为寄存器寻址和寄存器间接寻址

   IN AL，40H     ；寄存器寻址、立即寻址

   MOV [DI+BX]，AX  ；基址加变址寻址、寄存器寻址

   ADD AX，50H[DI]  ；寄存器寻址、寄存器相对寻址

   MOV AL，[1300H]  ；寄存器寻址、直接寻址

   MUL BL       ；寄存器寻址、目的操作数为隐含寄存器寻址

8. **已知（DS）= 1000H，（SI）= 0200H，（BX）= 0100H，（10100H）= 11H，（10101H）= 22H，（10600H）= 33H，（10601H）= 44H，（10300H）= 55H，（10301H）= 66H，（10302H）= 77H，（10303H）= 88H，试分析下列各条指令执行完后AX寄存器的内容。**

   ```
   MOV AX，2500H     （AX）=2500H
   MOV AX，500H[BX]   （AX）==4433H
   MOV AX，[300H]     （AX）=6655H
   MOV AX，[BX]      （AX）=2211H
   MOV AX，[BX][SI]    （AX）=6655H
   MOV AX，[BX+SI+2]   （AX）=8877H
   ```

9. 判断下列指令是否有错，如果有错，说明理由。 

   | SUB BL，BX               | 两个操作数的宽度不一样                     |
   | ------------------------ | ------------------------------------------ |
   | MOV [DI]，[SI]           | 两个操作数不能同时为内存数                 |
   | MOV AX，BYTE PTR[SI]     | 源操作数限定为字节，与目的操作数宽度不一致 |
   | MOV 125，CL              | 立即数不能做目的操作数                     |
   | MOV CS，BX               | 不能对CS实现传送操作                       |
   | SHR AX，4                | 只有当移位位数为1时，才能用立即数表达      |
   | MOV AH，[SI][DI]         | 不能用两个变址寄存器来实现寻址操作         |
   | SHL AX，CH               | 移位指令的移位位数用CL给出，不能用CH。     |
   | MOV  BYTE PTR[BX]，3456H | 将16位的立即数传送到一个字节的内存单元     |

10. **设（DS）= 1000H，（ES）= 2000H，（SS）= 3000H，（SI）= 0080H，（BX）= 02D0H，（BP）= 0060H，试指出下列指令的源操作数字段是什么寻址方式？它的物理地址是多少？**

    ```
    MOV AX，0CBH 立即寻址
    MOV AX，[100H] 直接寻址，物理地址为：10100H
    MOV AX，[BX] 寄存器间接寻址，物理地址为：102D0H
    MOV AX，[BP] 寄存器间接寻址，物理地址为：20060H
    MOV AX，[BP+50] 寄存器相对寻址，物理地址为：200B0H
    MOV AX，[BX][SI] 基址加变址寻址，物理地址为：10350H
    ```

11. **分别说明下列每组指令中的两条指令的区别.**

    **（1） AND CL，0FH 按位相“与”，高4位为“0000”，低4位保留原值；**

    OR CL，0FH 按位相“或”，高4位为原值，低4位为“1111”。

    **（2） MOV AX，BX  将BX寄存器的内容传送到AX寄存器中；**

    MOV AX，[BX] 将BX寄存器所指的内存单元的内容送AX寄存器中。

    **（3） SUB BX，CX  BX寄存器内容减去CX寄存器的内容，结果送回到BX；**

    CMP BX，CX  BX内容减去CX内容，结果只影响标志位。

    **（4） AND AL，01H AL内容与01H相“与”，结果为“0000000x”送回AL寄存器；**

    TEST AL，01H AL内容与01H相“与”，结果只影响标志位（ZF）。

    **（5） JMP NEAR PTR NEXT NEXT所指指令在当前指令的同段内；**

    JMP SHORT NEXT NEXT所指指令在当前指令的8位地址范围内。

    **（6） ROL AX，CL 循环左移，进位标志位不参与循环；**

    RCL AX，CL 循环左移，进位标志位参与循环。

    **（7） PUSH AX 将AX内容存入栈顶指针处，即进栈操作；**

    POP AX 将栈顶内容弹出装入AX寄存器中，即出栈操作。

12. **试分析以下程序段执行完后BX的内容为何？**

    MOV BX，1030H

    MOV CL，3

    SHL BX，CL  逻辑左移

    DEC BX  减一

    程序执行完后，**BX=817FH**

13. **编写能实现以下功能的程序段。**

    **根据CL中的内容决定程序的走向，设所有的转移都是短程转移。若D0位等于1，其他位为0，转向LAB1；若D1位等于1，其他位为0，转向LAB2；若D2位等于1，其他位为0，转向LAB3；若D0、D1、D2位都是1，则顺序执行。**

    ```
    ……
    AND CL，07H
    CMP CL，01H
    JZ LAB1
    CMP CL，02H
    JZ LAB2
    CMP CL，04H
    JZ LAB3
    CMP CL，07H
    JNZ OVER
    ……
    LAB1： ……
    LAB2： ……
    LAB3： ……
    OVER：……
    ```

14. **程序段1:**

    MOV AX,4455H

    MOV BX,7722H

    PUSH AX

    POP CX

    XCHG BX, CX

    程序执行后 **AX = 4455H, BX = 4455H， CX = 7722H**.

15. **程序段2：**

    MOV AX, 8765H

    MOV DX,4321H

    MOV CL，04

    SHL DX，CL

    MOV BL，AH

    SHL AX，CL

    SHR BL，CL

    OR DL，BL

    程序执行后 **AX= 7650H,  DX= 3218H** 

16. **程序段3：**

    TABLE    DW 11H，2233H，4455H，6677H，88H

    ​       …

    ​       MOV BX, OFFSET TABLE

    ​       MOV AX, [BX]

    ​       MOV DX, [BX+3]

    程序执行后，**AX = 0011H, DX= 5522H**

    

