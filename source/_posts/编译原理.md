---
title: 编译原理
date: 2021-05-24 14:38:57
tags:
typora-root-url: ..
---

# 文法和语言

**终结符和非终结符**

终结符可以简单地理解为「推导到这里就终结了」，也就是说不能再继续通过生成式向下推倒的元素就是终结符。

比如 T->abc。T 推导为串 abc 后已经得到了实质上的字符，不用在向下推导了，那么 T 为非终结符，abc 无法继续推导，则为终结符。（在一系列生成式中，式子左边的一定是非终结符，从未出现在式子左边的一定是终结符）

**句子与句型**

如果符号串x是由起始符号推导出的，则称x是文法G[S]的句型。

如果x中只包含终结符，则称x是文法G[S]的句子。

文法描述的语言是该文法一切句子的集合。

**四种文法**

0型文法：α→β，其中α至少包含一个非终结符。

1型文法（上下文有关文法）：α→β，其中|β|≥|α|，S→ε除外。

2型文法（上下文无关文法）：a→β，其中a是一个非终结符。

3型文法（规范文法）：A→a或A→aB.

4种文法是逐渐增加限制的，所以规范文法一定是0型文法、1型文法、2型文法，上下文无关文法也一定是0型文法、1型文法…

**上下文有关文法与上下文无关文法**

在应用一个产生式进行推导时，前后已经推导出的部分结果就是上下文。上下文无关指，只要文法的定义里有某个产生式，不管一个非终结符前后的串是什么，就可以应用相应的产生式进行推导。

上下文无关文法例子：

```
Code
产生式：
Sent -> S V O
S -> 人 | 天
V -> 吃 | 下
O -> 雨 | 雪 | 饭 | 肉
```

这个文法可以生成如下句子（共 16 种组合）：

｛人吃饭，天下雨，人吃肉，天下雪，人下雪，天下饭，天吃肉，……｝

可以看到，其中有一些搭配在语义上是不恰当的，例如”天吃肉“。其（最左）推导过程为：

Sent -> SVO -> 天VO -> 天吃O -> 天吃肉

而上下文有关文法例子如下：

```
Code
Sent -> S V O
S -> 人 | 天
人V -> 人吃
天V -> 天下
下O -> 下雨 | 下雪
吃O -> 吃饭 | 吃肉
```

可以看到，这里对 V 的推导过程施加了约束：虽然 V 还是能推出”吃“和”下“两个词，但是仅仅当 V 左边是”人“时，才允许它推导出”吃“；而当 V 左边是”天“时，允许它推导出”下“。这样通过上下文的约束，就保证了主谓搭配的一致性。类似地，包含 O 的产生式也约束了动宾搭配的一致性。（就是语法的强约束条件，导致上下文有关了）

这样一来，这个语言包含的句子就只有｛人吃饭，天下雨，人吃肉，天下雪｝这四条，都是语义上合理的。

以”人吃饭“为例，推导过程为：

Sent -> SVO -> 人VO -> 人吃O -> 人吃饭

（这与语法的歧义性还是不同的，要有所区分）

**1型文法比2型文法识别的语言集合更大？**

上例看到，感觉上下文有关文法所解释的句子集合更少。

这里的“1型文法比2型文法**识别的语言集合**更大” 这里的集合不是产生的结果集（字符串集合），而是语言规则集。 2型文法规则一定是1型文法规则，而有些语言能用1型文法规则描述，但用2型文法规则描述不出来。



## 语法树





### 最左推导/最右推导/规范句型

例如 E+E   (i+i)：

- E+E => E+i => i+i  ——最右推导
- E+E => i+E => i+i   ——最左推导

**最左推导**是指：任何一步α=> β都是对α中的最左非终结符进行替换。

同样，可定义**最右推导**（又称规范推导）：任何一步α=>β都是对α中的最右非终结符进行替换。

由规范推导所得到的句型称为**规范句型**。

### 二义性

一个文法的某个句子对应两棵不同的语法树，则这个文法是二义的。

或一个文法的某个句子有两个不同的最左（右）推导，则这个文法是二义的。

人们已证明，二义性问题是不可判定的，即不存在一个算法，它能在有限步骤内，确切地判断一个文法是否是二义的。（做题时就画两颗不同的语法树来证明其二义性）

### 自上而下的分析法

基本思想：从文法的开始符号出发，反复使用各种产生式，寻找“匹配”输入符号串的推导。即对任何输入符号串，从文法的开始符号（根结）出发，自上而下地为输入串建立一棵语法树，直到语法树结果正好是输入的符号串为止。

### 自下而上的分析法

基本思想：从输入串开始，逐步进行“归约”，直至归约到文法的开始符号。即从语法树的末端开始，步步向上“归约”，直到根结。



### 短语、直接短语、句柄

1. **短语**

   令文法G，开始符号为S，αβδ是G的句型（即S=>αβδ），如果S=>αAδ且A=>β，则称β是句型αβδ相对于非终结符A的短语。

2. **直接短语**

   如短语中有A=>β，则称β是句型相对于规则A→β的直接短语。

3. **句柄**

   一个句型的最左直接短语称为该句型的句柄。

⒈ 先证明前提

⒉ 给出语法树（注意文法是否是二义性的）

　如题文法G[E]:   E→ E+E|E*E|(E) | i

  证明i+i*i是G的一个句型，并指出这个句型的所有短语、直接短语、句柄。

⒊ 根据每棵语法树得出短语、直接短语、句柄

　（注意编号）





# 词法分析

## NFA→ DFA的转换（NFA的确定化）

### 确定化的有关运算

**（1）ε_closure(I) ——状态集合I的ε闭包(等价状态集)**

 设I是状态集的一个子集，ε_closure(I)定义为：

​    a.若S∈I，则S∈ε_closure(I)；

​    b. 若S∈I，那么从S出发经过任意ε弧而能到达的任意状态S’都属于ε_closure(I)；

**（2）Move(I, a)——状态集合I的a弧转换**

 假定I是状态集的一个子集，a是Σ中的一个字符，定义

​            Ia **＝** ε_closure(J)

其中J是所有那些可从I中的某一状态出发经过一条a弧而到达的状态结的全体。

　**(3)Ia＝ ε_closure(Move(I, a))**

### 子集化的具体过程

为了方便起见，令Σ中只有a,b两个字母，即Σ＝{a, b}

（1）构造一张表，此表的每一行有三列，第一列为I，第二列为Ia，第二列为Ib。即

|       I       |  Ia  |  Ib  |
| :-----------: | :--: | :--: |
| ε_closure(K0) |      |      |

首先置该表的第一列为ε_closure(K0)

（2）一般而言，若某一行的第一列的状态子集已确定，例如记为I，则可以求出Ia和Ib

（3）检查Ia和Ib是否已在表的第一列中出现，把未曾出现者填入到后面空行的第一列位置上。

（4）对未重复Ia 、Ib的新行重复上述过程(2)、(3)，直到所有第二列和第三列的子集全部在第一列中出现

**DFA 的初态位该表第一行第一列的状态**

**DFA 的终态为含有原 NFA 的终态的状态子集**

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20210516181303298.png" alt="image-20210516181303298" style="zoom:67%;" />

| I                    | Ia              | Ib               | S     | a    | b    |
| -------------------- | --------------- | ---------------- | ----- | ---- | ---- |
| {0,1,2,4,7}          | {1,2,3,4,6,7,8} | {1,2,4,5,6,7}    | 0     | 1    | 2    |
| {1,2,3,4,6,7,8}      | {1,2,3,4,6,7,8} | {1,2,4,5,6,7,9}  | 1     | 1    | 3    |
| {1,2,4,5,6,7}        | {1,2,3,4,6,7,8} | {1,2,4,5,6,7}    | 2     | 1    | 2    |
| {1,2,4,5,6,7,9}      | {1,2,3,4,6,7,8} | {1,2,4,5,6,7,10} | 3     | 1    | 4    |
| {1,2,4,5,6,7,**10**} | {1,2,3,4,6,7,8} | {1,2,4,5,6,7}    | **4** | 1    | 2    |

## DFA的化简

1. 将得到的状态进行划分 ∏ ，划分为两部分，一部分为终态，一部分为为非终组。
2. 继续进行划分，通过其可以匹配的字符进行判断，若该组内所有成员匹配字符都落在同一组内，即不可再分，否则重新划分组
3. 若 ∏new = ∏ ，则进入步骤4，否则返回2
4. 在分组 ∏new 每个组中选取一个状态作为代表，代表DFA的最简状态。

## 正规式→NFA

<img src="/images/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20210516193619828.png" alt="image-20210516193619828" style="zoom:67%;" />

# 自顶向下语法分析方法

对于任一输入符号串，从文法的识别符号出发，根据当前的输入符号，**唯一的确定一个产生式**，用产生式的右部的符号串替代相应的非终结符往下推导，或构造一棵语法树。若能推导出输入串或构造语法树成功则输入串是句子，否则不是。



## 开始符号FIRST集合

**理解**

FIRST(A)是以A开始符的集合，A的所有可能推导的开头终结符或者是ε

**例子**

1. 后面跟的不是非终结符

   ```
   ...
   A->aB|ε
   A->c
   ...
   First(A)={a,ε,c}
   ```

2. 后面跟非终结符（一）

   ```
   ...
   A->Ba
   A->b
   ...
   First(A)={b}
   ```

3. 后面跟的非终结符（二）

   ```
   ...
   A->Bc
   B->b|ε
   ...
   First(A)={b,c}
   ```

4. 后面跟的非终结符（三）

   ```
   ...
   A->BC
   B->b|ε
   C->c|ε
   ...
   First(A)={b,c,ε}
   ```

构造文法G的每一文法符号X，X ∈ (VT∪VN)

- 如果 X 是终结符号，那么FIRST(X)={X}

- 如果 X 是非终结符号，且 X -> Y1Y2Y3…Yk 是产生式
  - 如果a在FIRST(Yi)中，且 ε 在FIRST(Y1)，FIRST(Y2)，…，FIRST(Yi-1)中，那么a也在FIRST(X)中；
  - 如果ε 在FIRST(Y1)，FIRST(Y2)，…，FIRST(Yk)中，那么ε在FIRST(X)中；
- 如果X是非终结符号，且有X->ε，那么ε在FIRST(X)中

## 后跟符号FOLLOW集合

**理解**

Follow(A)为非终结符A后跟符号的集合，Follow(A)是所有句型中出现在紧接A之后的终结符或’#‘

**求解规则**

将标记 # 放到 FOLLOW(S) 中

按照下面两个规则**不断迭代**，直到所有的 FOLLOW 集合都不再增长为止

- 如果存在产生式 A -> αBβ ，那么 FIRST(β) 中所有非 ε 的符号都在 FOLLOW(B) 中；
- 如果存在产生式 A -> αB，或者 A -> αBβ 且 FIRST(β) 包含 ε，那么 FOLLOW(A) 中的所有符号都加入到 FOLLOW(B) 中

**理解求解规则**

1. 将标记 # 放到 FOLLOW(S) 中

2. 形如A -> αBβ

   （α可以是终结符或者非终结符或者直接为空，β可以是终结符或者非终结符，注意β不能为空，B后面要有东西）

   比如

   ```
   A->aBC
   A->aBd
   A->BC
   A->Bd
   ```

   那么 FIRST(β) 中所有非 ε 的符号都在 FOLLOW(B) 中；

3. 形如A -> αBα可以是终结符或者非终结符或者直接为空)或者A -> αBβ是一个产生式且β=>ε

   比如

   ```
   A->B
   A->cB
   
   A->dBC
   C->ε
   ```

   那么 FOLLOW(A) 中的所有符号都加入到 FOLLOW(B) 中

**例子一**

注意：[if] 是一个终结符，同理[b] [other] [else] [then]

```
G(S)：S->IETSP|O
I->if
E->b
O->other
L->else
T->then
P->LS|ε
```

| **First**           | **Follow**           |
| ------------------- | -------------------- |
| First(S)={if,other} | Follow(S)={#,else}   |
| First(I)={if}       | Follow(I)={b}        |
| First(E)={b}        | Follow(E)={then}     |
| First(O)={other}    | Follow(O)={else,#}   |
| First(L)={else}     | Follow(L)={if,other} |
| First(P)={else,ε}   | Follow(P)={else,#}   |
| First(T)={then}     | Follow(T)={if,other} |

例子一 中反馈的问题：

在求Follow(S)发现`P->LS|ε`也是存在的，那么follow(s)={#,else}+follow( p )，而算到follow( p )发现follow( p )=follow(s) 就不知道怎么算了

解答：

```
我们需要同时满足
follow(s)={#,else}+follow(p)
follow(p)=follow(s)
将第二个式子带入一式得到
follow(s)={#,else}+follow(s)
注意：不能将follow(s)约掉，而是要想怎么样上面的等式仍然成立
那么，我们就会发现follow(s)只能等于{#,else}
因为 {#,else}={#,else}+{#,else}是成立的
```

**例子二**

```
S→AB        S→bC
A→ ε        A→b
B→ ε        B→aD
C→AD        C→b
D→aS        D→c
```

| **First**        | **Follow**        |
| ---------------- | ----------------- |
| First(S)={ε,B}   | Follow(S)={#}     |
| First(A)={ε}     | Follow(A)={a,c,#} |
| First(B)={ε,a}   | Follow(B)={#}     |
| First(C)={a,b,c} | Follow(C)={#}     |
| First(D)={a,c}   | Follow(D)={#}     |

## Select集合

**理解**

1. 如果a不能=>ε，则 Select(A->a)=First(a)
2. 如果a=>ε，则 Select(A->a)=(First(a)-{ε})UFollow(A)

## LL(1) 文法的判别

### 满足定义

1. 求出能推出ε的非终结符
2. 求FIRST集合；
3. 求FOLLOW集合；
4. 计算SELECT集合。
5. 对同一非终结符的不同产生式求Select交集





## 某些非LL(1)文法到LL(1)文法的等价转换

### 存在左公因子  

解决方法：提取左公因子

 

若文法中存在形如：

```
A->ay|ab   
两个产生式左部第一个符号相同，则不符合LL（1）文法，指代不明，则表示存在左公因子

解决方法：
转换成 A->aM1,aM2，aM3....的形式：
得：
A->aM
M->y|b
则成功提取左公因子；
```

### 存在左递归

**（1）直接左递归** 

```
A->AB, A∈Vn，B属于V*
```

方法：左递归变右递归

```
P->β1P'|β2P'|…|βnP'
P'->α1P'|α2P'|…|αmP'|ε
```

例：给定文法G(S):

```
E->E+T|T
T->T*F|F
F->(E)|i
```

消除其直接左递归G(E):

```
E->TE'
E'->+TE'|ε
T->FT'
T'->*FT'|ε
F->(E)|i
```



**（2）间接左递归**

```
A->Bb
B->Aa
A,B∈Vn，a，b属于V*
```

（这里第二种情况注意，因为是左递归，所以看得就是第一个字符，一定要跟这个类型一样的A->B.... 以及B->A.... 这种才是左递归，如果A->B.... ,B->aA...,  这种就不是左递归了，因为样式不同，请注意）

同样消除左递归的方法：

如果是间接左递归，则先转换成直接左递归：

例子：

```
A->Bb | c
B->Aa
```

将B->Aa代入到另一个式子：

```
A->Aab | c
```

转换

```
A->cM
M->abM
M->ε
```



# 自底向上优先分析

## 算符优先文法

### 概述

算符优先分析法(Operator Precedence Parse)是仿效四则运算的计算过程而构造的一种语法分析方法。算符优先分析法的关键是比较两个相继出现的终结符的优先级而决定应采取的动作。

优点：简单，有效，适合表达式的分析。

缺点：只适合于算符优先文法，是一个不大的文法类。

### 算符优先关系的定义

- a < b 文法中有形如 A→…aB… 的产生式而 B=>b… 或 B=>Cb…
- a < b 文法中有形如 A→…ab… 或 A=>...aBb… 的产生式
- a > b 文法中有形如 A→…Bb… 的产生式而 B=>…a 或 B=>…aC

### FIRSTVT和LASTVT的构造规则

**Firstvt**
找Firstvt的三条规则：如果要找A的Firstvt，A的候选式中出现：

- A->a…，即以终结符开头，该终结符入Firstvt
- A->B…，即以非终结符开头，该非终结符的Firstvt入A的Firstvt
- A->Ba…，即先以非终结符开头，紧跟终结符，则终结符入Firstvt

**Lastvt**
找Lastvt的三条规则：如果要找A的Lastvt，A的候选式中出现：

- A->…a，即以终结符结尾，该终结符入Lastvt
- A->…B，即以非终结符结尾，该非终结符的Lastvt入A的Lastvt
- A->…aB，即先以非终结符结尾，前面是终结符，则终结符入Firstvt

### 构造算法优先关系表

- a=b 关系

  可直接查看产生式的右部，对如下形式的产生式

  A->...ab...

  A->...aBb...

  则有 a=b 成立

- a<b 关系

  对于所给表达式文法中终结符在前，非终结符在后的所有相邻符号对，有 b 属于FIRSTVT(B)，则 a<b 成立

  a<FIRSTVT()

- a>b 关系

  对于所给表达式文法中非终结符在前，终结符在后的所有相邻符号对，有 a 属于FIRSTVT(B)，则 b>a 成立

  LASTVT()>a

### 名词解释

- 素短语

  文法G某句型的一个短语是素短语，当且仅当它至少含有一个终结符，且除它自身之外不再含更小的素短语。

- 最左素短语

  在具有多个素短语的句型中处于最左边的那个素短语。

